<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[什么！你用的Java版本叫“Tiger🐯”？]]></title>
    <url>%2F2017%2F06%2F28%2F20170628%2F</url>
    <content type="text"><![CDATA[作为一个Java初学者，很多同学的精力都放到了Java语言本身的语法当中，或是开始纠结于各种算法，或是专研OO思想，还有人对各种设计模式趋之若鹜，总之开启了各种“高大上”的装逼模式……少年人，你可知道： “生活不止眼前的苟且，还有诗和远方的田野。”———————— 高晓松 今天就让我们先放下冷冰冰的代码，虚无缥缈的编程思想，来看点关于Java你应该知道的一些“趣知识”吧。 Java之父 这位看上去亲切和蔼的“花样”大叔，相信很多人都认识。他就是著名的Java之父—-詹姆斯.高斯林（James Gosling）。别看人家现在是一脸沧桑，想当初也是以一个“天才”少年的身份闪亮登场的。1955年的冬天，詹姆斯出生在加拿大的一个村庄里。12岁的时候，他用报废的电话机和电视机中的部件做了一台电子游戏机。附近农民的联合收割机出了问题也常常找他修理。14岁的时候，中学组织到附近大学参观，他记住了大学计算中心的门锁密码，从此开始偷偷地溜进计算中心，学习计算机编程。一年后（15岁），大学的天文系招他当了一名临时编程员，编写计算机程序来分析卫星天文数据。1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位。毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司。1990年，与Patrick Naughton和Mike Sheridan等人合作“绿色计划”，发展了一套语言叫做“Oak”，后改名为Java。1994年底，在硅谷召开的“技术、教育和设计大会”上詹姆斯.高斯林展示了Java程序。2000年，Java成为世界上最流行的电脑语言。2009年4月，甲骨文公司花费了74亿美元收购了SUN公司。但由于理念不合，不到一年詹姆斯.高斯林宣布从甲骨文公司离职。2011年3月29日，他在个人博客上宣布将加入谷歌，但几个月以后他又离开了。2011年8月30日，他加盟一家从事海洋机器人研究的创业公司Liquid Robotics，担任首席软件架构师。2017年5月22日，詹姆斯在Facebook上宣布他将加入到亚马逊。厉害吧👍👍👍，这位60多岁的IT大牛太能折腾了。有这么一位祖师爷，各位Java学员你们还怕什么？！😏😏😏 Java吉祥物说到Java，所有同学都应该认识那杯热气腾腾的咖啡杯，那么下面这个小家伙你认识吗？ 它叫做Duke（杜克），是由Joe Palrang在1992年创作出来的。Duke当时所扮演的角色是类似Office中小助手的功能，而那时的Java这门编程语言还不叫Java而被称之为Oak呢。另外大家也许都知道Java是开源的，那你知道Duke也是开源的吗？也就是说我们可以随意发挥我们的想象力，让Duke飞起来✈️～～～ Java全球排名Java初学者常常被教导说：Java是最流行的语言。说这话的人往往是微微一笑，高深莫测的样子；听这话的则是将信将疑，你们是不是王婆卖瓜，自卖自夸呀……那么编程语言有没有排名呢？谁排的，咋排的呢？其实在业内，我们还真有一个可靠的编程语言榜单，它叫做TIOBE排行榜。该榜单是根据互联网上有经验的程序员、课程和第三方厂商的数量，并使用搜索引擎（如Google、Bing、Yahoo!）以及Wikipedia、Amazon、YouTube统计出排名数据。其目的只是反映某个编程语言的热门程度，并不能说明一门编程语言好不好，或者一门语言所编写的代码数量多少。TIOBE开发语言排行榜每月更新一次排名，每年评选一个年度语言。我们来看看目前的最新排名情况： 给你个网址，可以随时可以查看：TIOBE排行榜单; Java版本演化及别名JDK1.0这是第一个发布的版本，发布时间是1996-1-23。当时语言的名字还被叫做Oak（橡树）。直到第一个稳定版本JDK1.0.2被发布出来，才被称之为Java。 JDK1.1这个版本发布的时间在1997-2-19，它主要添加的内容包括： 改进扩展了AWT的事件模型 添加了内部类 引入JDBC（Java数据库连接） 引入RMI（远程方法调用） 引入反射机制 在微软的Windows平台上引入JIT编译器（Just in Time，及时编译器）。 开始支持国际化和Unicode编码 J2SE1.2这是Java历史上的一个“里程碑”式的版本。它发布于1998年12月8日，并且从这个版本开始出现了几个名称上的变化： 从这个版本开始直到J2SE5.0，Java被更改为Java2； 从这个版本开始，版本名称从JDK改为J2SE，以便于区分其它扩展平台J2ME、J2EE。 从这个版本开始，开始公布每个Java版本的开发代号。J2SE1.2的开发代号是“playground”（操场）。意味，SUN公司给各位Java程序员提供了一个广阔的平台，大家High 起来。 这个版本提供的新内容包括： 增加strictfp关键字； 核心类中融入Swing图形API； SUN公司的JVM（Java虚拟机）首次装备JIT编译器； 引入集合框架； 引入Java插件applet支持； Java IDL（交互式数据语言），支持CORBA。 J2SE1.3开发代号为Kestrel（红隼），发布于2000年5月8日。引入新特性包括： HotSpot JVM首次被包含（发布是在1999年4月份）； 修改RMI，使其支持CORBA； JNDI（Java命名与目录接口）被包含在核心库当中； 引入JPDA（Java平台调试体系）； 引入Java声音API； 引入动态代理类。 J2SE1.4开发代号为Merlin（灰背隼），发布于2002年2月6日。引入新特性： 增加assert关键字； 引入正则表达式； 引入链式异常处理； 提供IPV6的支持； 提供非阻塞的输入输出（被称之为新的IO，NIO）； 提供日志API； 提供Image IO API支持读写格式为JPEG和PNG的图片； 提供XML解析和XSLT的处理； 引入安全和密码表达式； 引入Java Web Start； 引入Preferences API。 J2SE5.0开发代号为Tiger（老虎），发布于2004年9月30日。这个版本是Java版本史上第二个“里程碑”式的突破，它不断更新，一直持续到2009年年底，经历了Orcale收购SUN这一重大事件。在名称上，也经历了从原本的J2SE1.5更改为J2SE5.0，到JavaSE5这一系列的变化。引入新特性： 引入泛型； 增强循环，可以使用迭代方式； 自动装箱与自动拆箱； 类型安全的枚举； 可变参数； 静态引入； 元数据（注解）； 引入Instrumentation。 JavaSE6开发代号为Mustang（野马），于2006年12月11日发行，直到2017年1月17日。引入的新特性包括： 支持脚本语言； 引入JDBC 4.0 API； 引入Java Compiler API； 可插拔注解； 增加对Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access Protocol)的支持； 继承Web Services； 深入优化。 JavaSE7开发代号为Dolphin（海豚），于2011-07-28发行，直到2017-1-17。引入新特性： switch语句块中允许以字符串作为分支条件； 在创建泛型对象时应用类型推断； 在一个语句块中捕获多种异常； 支持动态语言； 支持try-with-resources； 引入Java NIO.2开发包； 数值类型可以用二进制字符串表示，并且可以在字符串表示中添加下划线； 钻石型语法； null值的自动处理。 JavaSE8开发代号为Spider（蜘蛛），于2014年3月18直到如今。引入新特性： Lambda表达式 Stream函数式操作流元素集合 接口新增：默认方法与静态方法 方法引用,与Lambda表达式联合使用 引入重复注解 类型注解 最新的Date/Time API (JSR 310) 新增base64加解密API 数组并行（parallel）操作 JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）元空间]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[打印万年历，你会吗？]]></title>
    <url>%2F2017%2F06%2F25%2F20170625%2F</url>
    <content type="text"><![CDATA[打印万年历，你会吗？啊，不会！那就跟我一起使用Java在控制台上打印一个简单的万年历吧！ 这个万年历怎么样，漂亮吧！ 你该不会天真的认为这是从控制台上打印出来吧？要是你真这么想，我可被你的天真打败了！ 要用Java实现这个万年历不是不可能，你还得会Java的swing图形用户界面开发。 我们还是来看看Java在控制台上打印的万年历长啥样？ 第一反应是不是好丑呀？别看它长得丑，这可是货真价实的万年历。 软件开发其实就好比一个人，最重要的是内涵(功能），而不是外表(界面）（其实外表也很重要）。这个万年历就很有内涵。不信，我们就一起来看一看如何实现万年历吧。 初学编程的同学在写代码时，习惯还没想好就开始写代码，写的过程中有问题又反复修改。如果是语文考试作文，恐怕你的作文最终已经改得面目全非，惨不忍睹。所以，这是一个非常不好的编程习惯。 好的编程习惯是解决问题前一定要先分析问题，把大问题逐步分成小问题，理清逻辑，自下而上，逐步实现。 其实，一句话就是先想好再动手。 问题分析 首先1970年是Unix系统诞生的时间，1970年就成为Unix的元年，1970年1月1号是星期四，现在大多的手机的日历功能只能显示到1970年1月1日这一天。不信，现在赶紧掏出手机看一看。那最大可以显示哪一年呢？我的手机显示的是2037年，你的呢？ 要想打印某年某月的日历，逐步分成小问题如下： 1&gt; 计算出本月的总天数 （注意：考虑闰年问题） 2&gt; 计算出本月的1号是星期几（其他号数对应的星期几就可以以此类推） 打印万年历格式 1&gt;打印标题格式 2&gt;打印内容格式 代码实现问题分析得差不多了，心里应该大致知道要实现哪些小功能，接着就一步步编写代码。 Java的JDK帮助文档中，有一个专门日历类－Calender。这个类封装了很多方法用于计算日历，我们正好使用它来完成万年历的开发。 下面写一个Calender简单小例子： 12345678public static void main(String[] args) &#123; Calendar nowc = Calendar.getInstance(); System.out.println(nowc.get(Calendar.YEAR)); // 当前年份 System.out.println(nowc.get(Calendar.MONTH));// 当前月份（从0开始) System.out.println(nowc.get(Calendar.DAY_OF_MONTH)); // 当前日期 System.out.println(nowc.get(Calendar.DAY_OF_WEEK)); //当前星期几（从1表示星期日开始） &#125; 输出结果如下（2017年6月9日 星期五）： 2017 5 9 6 Calendar类在实现万年历中的具体使用，我们通过代码进行说明，方法的使用有不清楚的地方可以自行查看JDK帮助文档。 判断是否闰年方法 1234567// 判断闰年（年份能被400整除或能被4整除同时不能被100整除）public static boolean isLeap(int year) &#123; if ((year % 400 == 0) || ((year % 4 == 0) &amp;&amp; (year % 100 != 0)))&#123; return true; &#125; return false;&#125; 计算本月天数 1234567891011121314151617// 计算本月天数public static int getDays(int year,int month) &#123; int days = 0; if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) &#123; days = 31; &#125; else if (month == 4 || month == 6 || month == 9 || month == 11) &#123; days = 30; &#125; else &#123; if (isLeap(year)) &#123; //判断是否闰年 days = 28; &#125; else &#123; days = 29; &#125; &#125; return days;&#125; 计算本月第一天星期几 123456789// 计算本月一号星期数public static int getfirstWeek(int year,int month) &#123; Calendar calendar = Calendar.getInstance(); calendar.set(year, month-1,1); //设置日期为本月一号 int week = calendar.get(Calendar.DAY_OF_WEEK)-1; return week;&#125; 打印标题 1234567891011// 打印标题public static void printTitle(int year, int month) &#123; System.out.printf("%32s\n", year + " 年 " + month + " 月 "); System.out.println("----------------------------------------------"); String[] weeks = &#123; "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" &#125;; for (int index = 0; index &lt; weeks.length; ++index) &#123; System.out.printf("%-15s", weeks[index]); &#125; System.out.println();&#125; 打印内容 123456789101112131415161718// 打印内容public static void printBody(int year,int month) &#123; int week = getfirstWeek(year, month); for (int index = 0; index &lt; week; ++index) &#123; String blank = " ";// 空字符串占位 System.out.printf("%-8s", blank); &#125; int days = getDays(year, month); for (int index = week+1,day = 1; index &lt; days + week+1; ++index,day++) &#123; if (index % 7 == 0) &#123; System.out.printf("%-8d\n",day); //换行 &#125; else &#123; System.out.printf("%-8d",day); &#125; &#125;&#125; 打印万年历 1234567891011121314151617//打印万年历public static void main(String[] args) &#123; // 控制台输入年份和月份 Scanner input = new Scanner(System.in); System.out.println("请输入年份："); int year = input.nextInt(); System.out.println("请输入月份："); int month = input.nextInt(); // 打印标题 printTitle(year, month); // 打印内容 printBody(year, month);&#125; 总结你现在觉得打印这个简单的万年历其实并不简单，很有内涵了吧？涉及很多编程的细节和小问题的处理。是不是感觉一下子脑袋又不够用了？ 还等什么，现在就跟着上面的代码，自己再敲一遍。边敲那思考，直到自己搞明白为此。]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[你应该知道的Java创建对象的四种方式]]></title>
    <url>%2F2017%2F06%2F22%2F20170622%2F</url>
    <content type="text"><![CDATA[面向对象程序设计(OOP)是当今主流的程序设计规范，它已经基本取代了结构化、过程化的程序设计。Java就是面向对象的，使用java开发程序，不管做什么样的操作，我们第一步都是从创建对象、获取对象开始，有了对象我们就可以完成一切我们所需要的程序了。 那怎么样才能创建对象？java中有哪些创建对象的方法？我们今天就来详细了解一下。 一：new运算的方式创建对象首先我们有一个关于宠物的类Dog1234567public class Dog &#123; String name; int age; public void show()&#123; System.out.println("我叫"+this.name+"今年"+this.age+"岁了"); &#125;&#125; 当我们程序中需要出现一只狗狗的时候，我们就可以使用new来创建一个具体的对象了123Dog dog1=new Dog();dog1.name="xiaohei";dog1.age=3;在这里我们就通过了new的方式获得了一个具体的对象，并且起名为小黑，年龄为3岁。 现在，dog1就带表了堆中刚才所实例化出来的对象。以后我们要操作刚才new出来的对象就可以通过dog1来操作了，例如我们让小狗打个招呼(调用Dog类的show方法)：1dog1.show(); 二：通过反射的方式创建对象Java的反射技术是java程序的特征之一，它允许运行中的Java程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性。 反射的作用：1）可以通过反射机制发现对象的类型，找到类中包含的方法、属性和构造器2）可以通过反射创建对象并访问任意对象方法和属性 第二种创建java对象的方式就是通过反射来创建了。 还是我们之前用过的Dog类，首先JVM利用ClassLoader(类加载器)先将Dog类加载到内存，然后马上产生了一个Class类型的对象，该对象可以看成是一个模型，以后无论创建多少个Dog类的实例都是利用该模型来生成(一个类所对应的Class类型的对象只有一个)。 通过反射创建对象第一步：需要获得class对象1Class clazz = Dog.class; 这样获取到类对象之后就可以通过newInstance()这个方法来获取具体的对象了，需要注意的是这个方法的返回值是Object类型，我们需要进行转型操作12Class clazz = Dog.class;Dog dog = (Dog)clazz.newInstance();这样我们就通过反射的方式创建好了java对象,newInstance()和new的区别如下： newInstance: 弱类型。低效率。只能调用无参构造。new: 强类型。相对高效。能调用任何public构造。 在这里需要注意的是，newInstance()这个方法只能够调用无参的构造函数(其实这也符合javabean规范，一个类必须拥有一个无参构造函数)，现在我们在Dog类中写有参构造函数(默认覆盖无参构造函数)，值得注意的是，当我们写了有参构造函数之后，系统将不再提供默认的无参构造函数，如果需要的话，需要你自己写12345678public class Dog &#123; String name; int age; public Dog(String name,int age)&#123; this.name=name; this.age=age; &#125;&#125;现在再去调用newInstance()方法12Class clazz=Dog.class;Dog dog=(Dog) clazz.newInstance(); 现在程序运行结果为java.lang.InstantiationException，着就是程序没有无参构造函数而使用newInstance()方法引发的错误了 当然如果你需要调用有参构造函数的话，可以通过以下的办法：1234Class clazz=Dog.class;Constructor constructor=clazz.getConstructor(String.class,int.class&#125;);Dog dog=(Dog) constructor.newInstance("xiaohei",3&#125;);System.out.println(dog.name+" "+dog.age); 程序的第二行我们调用Class对象的getConstructor方法，然后在参数列表中传入String和int，因为我们的有参构造函数的参数列表就是这样规定的，现在我们就获取到了前边定义好的Dog类的有参构造函数了第三行我们通过获取的Constructor对象调用newInstance方法，然后在方法中传入Object类型的参数列表，因为我们的有参构造函数需要这些值，这样就可以通过反射的方式创建只有有参构造函数的对象了 三：通过对象反序列化的方式来创建当我们使用反序列化一个对象的时候，JVM会给我们创建一个对象。但是，反序列化的时候JVM并不会去调用类的构造函数(前边两种方式都会去调用构造函数)来创建对象，而是通过之前序列化对象的字节序列来创建的。 序列化对象必须实现Serializable这个接口把对象转为字节序列的过程称为对象的序列化把字节序列恢复为对象的过程称为对象的反序列化 1234567public class Dog implements Serializable&#123; String name; int age; public void show()&#123; System.out.println("我叫"+this.name+"今年"+this.age+"岁了"); &#125;&#125; 需要注意的是：Dog类需要实现Serializable这个接口才可以被序列化/反序列化，否则会出现java.io.NotSerializableException异常 对象序列化通常有两种用途： 1）将对象的字节序列永久的保存到硬盘上例如web服务器把某些对象保存到硬盘让他们离开内存空间，节约内存，当需要的时候再从硬盘上取回到内存中使用 2）在网络上传递字节序列当两个进程进行远程通讯的时候，发送方将java对象转换成字节序列发送(序列化)，接受方再把这些字节序列转换成java对象(反序列化) 当Dog类实现了Serializable接口后，我们现在将Dog对象序列化1234567Dog dog=new Dog();dog.name="xiaohei";dog.age=3;FileOutputStream fos = new FileOutputStream("dog.txt");ObjectOutputStream ops = new ObjectOutputStream(fos);ops.writeObject(dog);System.out.println("dog对象序列化完成");通过ObjectOutputStream的writeObject方法，我们就将一个对象完成了序列化 现在我们再次将刚才序列化后的对象反序列化回来，这次用到的是ObjectInputStream的readObject方法：12345FileOutputStream fos=new FileOutputStream("dog.txt");ObjectInputStream ois=new ObjectInputStream(fos);Dog dog=(Dog) ois.readObject();System.out.println("我叫"+dog.name+"今年"+dog.age+"岁了");System.out.println("对象反序列化完成"); 这样我们就使用了对象的序列化完成了java对象的创建 四：通过clone的方式来创建clone方法来源于java中object类，在jdk中的解释为：该方法返回一个此对象的副本。clone顾名思义就是复制的意思。所谓复制对象就是在内存中分配一个和原一模一样的空间，在此创建新的对象。 我们现在就来完成clone的实验，首先我们需要在需要clone的类中实现Cloneable接口，否则会出现java.lang.CloneNotSupportedException异常,由于Object类中clone方法是protected 修饰的，所以我们必须在需要克隆的类中重写克隆方法12345678910 public class Dog implements Cloneable&#123; String name; int age; @Override protected Object clone() throws CloneNotSupportedException &#123; //TODO Auto-generated method stub return super.clone(); &#125;&#125;现在进入实验1：123Dog d1=new Dog();Dog d2=d1;System.out.println(d1==d2);返回值为true，因为在这个地方只有d1是真实创建了对象，d2来源于d1的赋值，引用地址值一样(代表是同一个对象)，所以==判断结果为true 现在进入实验2：1234 Dog d1=new Dog();Dog d2=(Dog) d1.clone();System.out.println(d1==d2); 实验结果为false，因为clone是真实在内存中重新划分一块区域来存储新的对象，d1和d2是两个不同的对象所以返回结果值为false 这样我们就使用了对象的克隆的方式完成了java对象的创建]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试经典问题，谈谈你对OOA,OOD,OOP的理解]]></title>
    <url>%2F2017%2F06%2F19%2F20170619%2F</url>
    <content type="text"><![CDATA[OOA（面向对象分析）、OOD（面向对象设计）、OOP（面向对象编程），这3个概念，对于我们JAVA程序员来讲，或多或少应该都有所了解，或者说至少都听说过。但是要谈到对其理解，可能对于多数入行不深的从业者来说，确实不是那么容易做到。特别是对于绝大多数的3年以内的低中级软件工程师而言。因为他们的工作更多是需要按照项目经理分配的任务来编写功能代码，很少有多余的时间去阅读或者思考一些概念性的东西。说起这个问题，我也在网络上也搜索过很多的资料，大多摘录至书籍，比较官方化。让初学者无从理解。为了广大的新从业者或者应聘者，在这里，我们以一种实例的方式来对这3个概念进行重新的阐述： 业务场景：建行卡持有者，张三与李四两人，现在需要张三给李四转账人民币5000元整。按照业务分析后的流程图如下: 对于分析业务流程，常见的2种：面向过程分析（POA），面向对象分析（OOA）面向过程分析（Procedure Oriented Analysis）：是一种以过程为中心的编程思想，以数据流向为主要导向。为了解决问题，将解决问题的业务过程，按照一定的顺序划分成为一个又一个的事件，然后再封装成一个又一个的函数，最后由一个函数统一的按照顺序一步一步的调用即可。在面向过程分析中，顺序很重要，要实现功能只需要按照一定的顺序相互调用函数即可。 上述业务场景按照面向过程分析出来的结果就是： 程序检查张三卡中余额是否足够5000元人民币（事件1，满足则调用事件2） 程序从张三卡中扣除5000元人民币（事件2） 程序向李四卡中加入5000元人民币（事件3） 程序检测李四卡中是否正常入账（事件4，满足则结束整个业务） 程序向张三卡中加入5000元人民币（事件5） 在上述过程中，我们将这个业务过程，分成了5个步骤，也叫做5个事件，那么如果需要在程序中完成该转账业务的话，那么我们只需要按照1-2-3-4-5这样的顺序依次调用函数方法即可。在这个过程中，你会发现我们函数调用的顺序一定是不能变化的，变了就出问题了…… 面向对象分析（Object Oriented Analysis）:是一种以对象为中心的编程思想。利用从问题域中的词汇表中找到类与对象。那么说到这里，很多人对问题域又不是很清楚了，问题域：说的简单直接一点，问题域就是客户告诉你的要求，他要干什么。问题域并不特指需求，很多时候，客户所提的需求很多地方都有关联，所以在很多场合，客户所提的需求，还需要需求分析师多角度的帮助客户理清与完善。那么在客户需求范围中，衍生出来的他想要告诉你做的事，就是问题域，包括后期需求发生的变化，同样隶属于问题域的范围。用一个图来表示：需求分析文档，规格说明文档，以及程序之间的关系： 从上述业务场景的分析中，我们可以抽离出的类与对象有：抽离出来的类型有：汇钱者类，收钱者类，货币类。而张三只能算是汇钱者类中的一个实例，也被称之为汇钱者对象，李四只能算是一个收钱者类中的一个实例，也被称之为收钱者对象。那么额度为5000的人民币也只是货币类的一个具体实例。通常汇钱者类，收钱者类，货币类，我们都统一称之为：领域模型类，张三，李四，5000元人民币我们都统一称之为：领域对象。作为面向对象分析来说，我们最为重要的就是要分析出领域对象的行为。领域对象的行为主要是为后期的面向对象设计（OOD）提供接口依据，而属性作为分析阶段不是我们的重点。就上述3种领域对象而言，张三这个实例，可以查询自己卡中余额，可以从余额中取出5000元，也可以将外来的钱加入到自己的账户中。李四这个实例，可以查询自己卡中余额，可以将外来的钱加入到自己的账户中。而5000元人民币只是数据的传输携带者，没有任何行为可言。 在JAVAEE项目中，组织业务逻辑的方式：事务脚本（面向过程设计 POD）、领域模型（面向对象设计 OOD）事务脚本（面向过程设计 POD）：它是纯面向过程的一种组织业务逻辑的方式，在JAVAEE项目，是一种非常常见的设计方式，做法很简单，将POA分析后的结果封装成JAVA对应的方法即可，然后在业务层中统一按照顺序调用接口。将领域对象（人民币）去掉行为，只保留属性即可，用于数据传输。以数据流向为主要导向。 按照上述的业务场景来设计：保留失去行为的领域对象（人民币），同时抽离出一个业务层的接口类，多个持久层的数据访问接口类，在业务层接口中提供一个统一的业务调用方法transferAccount(),在数据库发生关系的持久层，提供一系列事件方法：queryBalance(),reduceBalance(),increaseBalance();使用UML类图表示为： 当然还有一系列的表示手段，比如：包图，对象图，序列图，用例图…… 这里就不一一设计了。 领域模型（面向对象设计 OOD）（Object Oriented Design）：主要是正确有效的构造出复杂系统的抽象结构，将面向对象分析后的结果，作为面向对象设计的模型，通常用于展示被设计系统的逻辑模型（业务逻辑如何设计），物理模型（系统如何划分，层次如何划分，如何部署……），静态模型（组成系统的元素：类，接口）和动态模型（对象的调用……）。将OOA分析的结果作进一步的规范化整理，以便能够被OOP直接接受。 概念可能比较生硬，那么说的直白点，设计阶段的任务就是： 按照面向对象的方式将系统分解成不同的模块化，或者系统再次划分为子系统，直到划分到可设计的最小粒度为止【垂直分块，水平分层】。 使用不同的表示方法来展示被设计系统的逻辑模型（业务逻辑如何设计），物理模型（系统如何划分，层次如何划分，如何部署……），静态模型（组成系统的元素：类，接口）和动态模型（对象的调用……）【常用的表示法手段：UML各种图形】。 需要注意的是：层次结构并非就一定是三层结构，也可以是多层，具体分几层需要根据项目的复杂度来决定，如果没有过多的业务逻辑，只有简单的CRUD的话，那么三层结构足以应付一切。 按照上述的业务场景来设计：对于领域逻辑来说，三层结构就不能满足其业务逻辑复杂度了，可能这时整个系统可能是四层，五层，或者多层……，我们这个例子，暂时定为四层结构：控制层、业务层、领域逻辑层、数据访问层。在设计领域对象时，保留失去行为的领域对象（人民币），转钱对象，收钱对象，同时抽象出一个业务层的业务接口用于简单的调度业务逻辑，多个持久层的数据访问接口类。 在OOA阶段，我们分析出张三这个实例，可以查询自己卡中余额，可以从余额中取出5000元，也可以将外来的钱加入到自己的账户中。那么它就应该对应着对应的3种行为方法。李四这个实例，可以查询自己卡中余额，可以将外来的钱加入到自己的账户中，那么它就应该对应着对应的2种行为方法。而5000元人民币只是数据的传输携带者，没有任何行为可言 如果采用UML中类图的表示法来看，图形应该如下：（在同一个图中，相同名称的元素代表同一元素）在这张图中，我们的层次就是4层结构，甚至我们还可以再分为5层，6层等，所以一般领域模型适用于业务需求较为复杂的情况。业务层仅仅是为了梳理业务流程，而真正的业务逻辑则交由领域层的领域对象之间相互调用对方的方法来实现业务逻辑。比如要转钱，就需要转钱者领域对象，减少自己的余额后，调用收钱者领域对象，添加自己的余额。当然真正的银行转钱复杂度，绝对远高于这个场景。 还需要使用到事件驱动模型，以及消息队列等一系列的技术，当然具体情况具体分析。 面向对象编程（OOP）面向对象编程（Object Oriented programming）：将面向对象设计后的抽象，采用面向对象的方式来实现的方法，就叫做面向对象编程。在这种方法中，程序被组织成许多相互协作的对象，每个对象都是一个类的实例。利用对象构成业务逻辑的组成基本元素（组合模式的层次结构），而不是采用算法。组成程序的基本元素是一个又一个的基础组件（类），那么组件就是我们层次结构所对应的接口或接口的实现类，那么程序就是由一个又一个实现类的实例相互协作来完成业务逻辑的实现。 总体来说： 面向对象分析的结果可以作为面向对象设计的模型，而面向对象设计的结果则可以作为面向对象编程的蓝图，应用程序需要由编程才能实现。]]></content>
      <categories>
        <category>OOAD</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[异常处理概述]]></title>
    <url>%2F2017%2F06%2F16%2F20170616%2F</url>
    <content type="text"><![CDATA[1.1 异常的概念异常指的是运行期出现的错误，也就是当程序开始执行以后执行期出现的错误。出现错误时观察错误的名字和行号最为重要。在这个世界不可能存在完美的东西，不管完美的思维有多么缜密，细心，我们都不可能考虑所有的因素，这就是所谓的智者千虑必有一失。同样的道理，计算机的世界也是不完美的，异常情况随时都会发生，我们所需要做的就是避免那些能够避免的异常，处理那些不能避免的异常。这里我将记录如何利用异常还程序一个“完美世界”。 异常情况例如： 工厂生产，原料用尽 高速路上车没油 家里灯泡断电 1.2 异常分类 错误: 错误不是异常，是用户和程序无法控制的问题，这是系统内部的错误。 检查异常: 检查异常通常是用户错误或者不能被程序所预见的问题，例如，打开一个文件，但是文件不存在，这中错误称为检查异常，必须由java语言来处理。 运行时异常: 运行时异常是程序在运行过程中可能发生的，可以被程序员避免的异常，可以被忽略，提示我们开发人员进行处理。 1.3 异常的控制流程首先来看一段代码：12345678910111213141516171819202122232425262728public class Demo01 &#123; public static void main(String[] args) &#123; System.out.println("进入main方法"); method1(); System.out.println("退出main方法"); &#125; public static void method1()&#123; System.out.println("进入method1方法"); method2(); System.out.println("退出method1方法"); &#125; public static void method2()&#123; System.out.println("进入method2方法"); System.out.println("excute method2"); System.out.println("退出method2方法"); &#125;&#125;进入main方法进入method1方法进入method2方法excute method2退出method2方法退出method1方法退出main方法 总结：方法调用栈中的顺序为先进后出。 上面的三个方法都被押入到内存的方法栈中，如果说某一段代码出现了异常那代码会如何执行呢？123456public static void method2()&#123; System.out.println("进入method2方法"); int n = 10/0; System.out.println("退出method2方法");&#125; 在method2中加入了 int n ＝ 10/0；程序运行到这句话是肯定要抛出异常。那我们会得到什么结果呢？ 123456789 Exception in thread "main" 进入main方法进入method1方法进入method2方法java.lang.ArithmeticException: / by zero at com.lovo.test.Demo01.method2(Demo01.java:17) at com.lovo.test.Demo01.method1(Demo01.java:12) at com.lovo.test.Demo01.main(Demo01.java:6) main方法在调用栈的最底部，method2在最顶部，如果method2抛出一个异常，method2就会从栈中被取出， 同时将异常继续抛给调用他的method1方法，发现method1并没有处理这个异常，那直接抛给main方法，并从栈中退出。 这时main方法方法也没有处理异常，就有java虚拟机来处理这个异常，虚拟机会创建一个exception对象将信息打印到控制台，然后结束程序。 通过画图来分析异常抛出的流程！ 1.4 异常的体系结构 通过api来进行异常类的查看和分析。 1.5 捕获异常在网上看了这样一个搞笑的话：世界上最真情的相依，是你在try我在catch。无论你发神马脾气，我都默默承受，静静处理。对于初学者来说异常就是try…catch如果我们发现程序某段代码会抛出异常，那我们要去捕获这个异常。 Java异常处理的五个关键字：try、catch、finally、throw、throws 例子：12345678910111213141516171819202122232425/** * 定义一个try块 * 在try块中定义两个变量，int x，int y； * 每次循环，x－－ y+＝10/x； * catch块捕获异常，如果出现异常那就输出 异常 * 返回一个y的值 * @return */public int test()&#123; try &#123; int x = 100; int y = 0; while(x&gt;-1)&#123; x--; y +=100/x; &#125; return y; &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println("执行try循环抛出异常了"); return -1; &#125;&#125;多个catch块使用12345678910111213141516171819202122232425 /** * 如果有多个catch块，一定要注意异常的类型必须从小到大的定义，从子类父类 */public void test()&#123; try &#123; Scanner sc = new Scanner(System.in); System.out.println("请输入一个数字"); int num = sc.nextInt(); int res = 100/num; &#125;catch (ArithmeticException e) &#123; System.out.println("输入的数字不能为0"); &#125;catch (InputMismatchException e) &#123; System.out.println("请输入数字"); &#125;catch (Exception e) &#123; System.out.println("未知的错误"); &#125; finally&#123; System.out.println("代码执行完毕，即将保存数据"); &#125; &#125; 1.6 申明并抛出异常1.6.1 throw和throwsthrow：将异常进行抛出（动作） throws：声明将要抛出何种类型的异常（声明） 例子： 12345678910111213141516171819 /** * throws Exception代表当前方法一旦发生异常将这个异常抛给调用中进行处理 * 如果不知道具体什么异常，可以用exception来代替 * throw 就表示执行抛出异常这个动作 * @throws Exception */public static void method2(int m) throws Exception&#123; System.out.println("进入method2方法"); if(m==0)&#123; throw new Exception(); &#125;else&#123; int n = 10/m; &#125; System.out.println("退出method2方法");&#125; 在method方法里面就必须要处理这个异常 123456789101112 public static void method1()&#123; System.out.println("进入method1方法"); try &#123; method2(0); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println("退出method1方法");&#125; 1.6.2 重写方法异常 父类中未抛出异常 创建一个parent父类 12345678public class Parent &#123; //父类中的测试方法，打印相应语句以便测试 public void test() &#123; System.out.println("parent test"); &#125;&#125; 子类继承没有抛出异常的父类 123456789101112public class Child extends Parent &#123; public void test() throws Exception &#123; System.out.println("child test"); &#125; public static void main(String[] args) &#123; Parent test = new Child(); test.test(); &#125;&#125; 结果：编译不通过。IDE告诉我们“overridden method does not throw ‘java.lang.Exception’”，好尴尬不是么！不过还好，我们吸取了教训，知道了父类未抛出异常时，子类也不能抛出异常的约定，至少没在项目发布上线后才发现问题，万幸万幸。 父类中抛出异常 12345678public class Parent &#123; //和上面类似，只是抛出了一个异常 public void test() throws Exception &#123; System.out.println("parent test"); &#125;&#125; 同样的，再搞一个子类出来，或者也可以将上面的子类稍作修改。如下： 1234567891011public class Child extends Parent &#123; public void test() &#123; System.out.println("child test"); &#125; public static void main(String[] args) &#123; Parent test = new Child(); test.test(); &#125;&#125; 总结：编译…又报错了。main函数中test.test()这一行有问题，必须要抛出一个异常。try..catch一下，再次编译运行，屏幕打印出child test字样。 1234567891011public class Child extends Parent &#123; public void test() &#123; System.out.println("child test"); &#125; public static void main(String[] args) &#123; Child test = new Child(); test.test(); &#125;&#125; 总结：编译通过。引用句柄是不是父类类型时，子类可以不用抛出异常。 如果…我子类不是抛出Exception，而是其子类比如IOException呢？ 12345 public void test() throws IOException &#123; System.out.println("child test"); &#125; 总结：编译通过，main方法里面正常打印出child test 那我把子类和父类的异常掉个包应该也没问题吧： 1234567public class Parent &#123; //父类抛出IOException public void test() throws IOException &#123; System.out.println("parent test"); &#125;&#125; 123456789101112131415public class Child extends Parent &#123; public void test() throws Exception &#123; System.out.println("child test"); &#125; public static void main(String[] args) &#123; Parent test = new Child(); try &#123; test.test(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 总结：竟然又报错了。看来街坊邻居们传的没错，继承体系就是这么“小气”，子类的异常类型必须和父类相同或者是其子类]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自增（++） 与 自减（--）]]></title>
    <url>%2F2017%2F06%2F13%2F20170613%2F</url>
    <content type="text"><![CDATA[你还记得自增（++）和 自减（–）吗？在程序员生涯中，我们在编写代码时，时常会用到 ++ 和 –, 对于这些特殊的运算符的含义和用法，你是否真明白这些运算符的含义? 在编码过程中，我们经常会使用 i=i+1（或则 i=i-1 ）。 i=i+1; // 表示 变量 i+1的值重新赋值给变量 i（也就是 i 自动增加 1 ); i=i-1; // 表示 变量 i-1的值重新赋值给变量 i（也就是 i 自动减 1 ); 在编程语言中存在着一种特殊的运算符， 自增运算符（++） 和 自减运算符（–），这种特殊的运算符则用来表示 变量的 自增 1 或则 自减 1。 例如： i++ 则表示 i=i+1 (也可以把i++ 看做为 i=i+1的简写方式) i– 则表示 i=i-1 (也可以把i– 看做为 i=i-1的简写方式) 自增（++）: 将变量的值加1，它分为 前缀式（ 如 ++i ）和 后缀式（ 如 i++ ) 自减（–）: 将变量的值减1，它分为 前缀式（ 如 –i ）和 后缀式（ 如 i– ) 运算符采用 前缀式和后缀式 对本身的影响都是一样的，都是加1或者减1。(也就是说： ++i 和 i++ 都表示 i=i+1) 但是 当把他们作为其他表达式的一部分，两者就有区别了。如：前缀式： j = ++i 表示先运算，再赋值。后缀式： j = i++ 表示先赋值，再运算。 先看一段代码(前缀式)123456789public class Test &#123; public static void main(String[] args) &#123; int i=10; int j=0; j=++i; // 前缀式:表示先运算 则：i=i+1 =&gt; i=10+1 =&gt; i=11, //再赋值:则:j=i =&gt; j=11 System.out.println("j="+j+", i="+i); // 最后结果为 j=11, i=11; &#125; &#125; 再看一段代码(后缀式)123456789public class Test &#123; public static void main(String[] args)&#123; int i=10; int j=0; j=i++; // 后缀式:表示先赋值 则： j=i =&gt; i=10 =&gt; j=10, //再运算：则 i=i+1 =&gt; i=10+1 =&gt; i=11 System.out.println("j="+j+", i="+i); // 最后结果为 j=10, i=11; &#125;&#125; 自减（–）作为 其他表达式的一部分与 自增（++） 一样，这里我就不重复举例了。 再看看下面这段代码12345678public class Test &#123; public static void main(String[] args) &#123; int i=10; int j=(i++)+(++i); int k=(--i)+(i--); System.out.println("i="+i+", j="+j+",k="+k); &#125;&#125; 这段代码运算后 i=?, j=?, k=? 答案为： i=10, j=22, k=22 如果你回答正确了，那说明你对 自增（++）和 自减（–） 运算符 已经算是掌握了。 分析一下上面的代码 i=10； i++ 后缀写法，表示先赋值再运算，也就是 参与运算的值为 10; 然后 i=i+1 此时 i 的值变成为 11 ++i 前缀写法， 表示先运算再赋值，也就是先 i=i+1 此时 i=11+1 侧 i=12 然后在赋值，也就是参与运算的值为 12 j = 10 + 12; 最后 j=22，i=12 –i 前缀写法，表示先运算再赋值 此时先 i=i-1 ，侧 i=12-1 =&gt;i=11 此时参与运算的值为 11 i– 后缀写法，表示先赋值在运算 此时先赋值，则参与运算的值为 11， 在运算 i=i-1=&gt;i=11-1=10 k=11+11 =22; 最后得出答案为：i=10, j=22,k=22; 再问一个问题？下面这段代码能编译通过吗？1234567891011public class Test &#123; public static void main(String[] args) &#123; float f = 1.1f; f++; double d = 2.1d; d++; char c='a'; c++; System.out.println(f+" "+d+" "+c); &#125;&#125; 如果你回答可以，那么你已经掌握了 自增（++） 和 自减（–）运算符了。 答案为： f=2.1 d=3.1 c=b。 自增与自减运算符还遵循以下规律 ： 可以用于整数数据类型byte、short、int、long，浮点类型float、double，以及字符类型 char。 在Java5.0及以上版本中，它们可以用于基本类型对应的包装器类Byte、Short、Integer、Long、Float、Double、Character。 它们的运算结果的类型与被运算的变量的类型相同。 关于面试题来看看面试题的代码:123456789public class Test &#123; public static void main(String[] args) &#123; int j=0; for (int i = 0; i &lt; 100; i++)&#123; j = j++; &#125; System.out.println(j); &#125;&#125;也许你的第一反应和我一样， j=100; 结果答案： j=0 ； 原来这是因为Java编译器使用了中间缓存变量的机制java的编译器在遇到i++和i–的时候会重新为变量运算分配一块内存空间，以存放原始的值，而在完成了赋值运算之后，将这块内存释放掉。 首先看一下如果是 j = i++ 的情况： 所以上图的操作等于如下操作 123temp = i;i=i+1; j=temp; 我们再看看 j = j++ 的情况 所以 最后一次循环后的 j 还是等于 0; 因此对于自增（++）、自减（–）运算符的变量进行赋值时都需要特别注意。 如果在程序中只输入i++就不会出现这个方面的问题，所以大家在以后的程序中如果使用到i=i++的时候要格外小心，一般只需要用 i++ 就不会有问题了。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[switch和if else语句到底用谁]]></title>
    <url>%2F2017%2F06%2F10%2F20170610%2F</url>
    <content type="text"><![CDATA[大家都知道在Java中一共有两种选择语句分别是switch与if语句，但究竟什么时候用？用哪一种好呢？这一直是大家心中的一个小疑虑。 现在简单的回顾switch与if语句的基本构造，再深入了解它们的使用区别。首先回顾下switch与if的基本结构 switch说得再多，不如直接上代码123456switch(choose)&#123; case 1:语句1;break; case 2:语句2;break; case 3:语句3;break; default:默认语句;&#125; 上述是一个简单的switch语句的例子，根据choose的取值不同，选择不同的case语句执行；如果没有匹配任何case值，则执行默认语句。 注意事项：1.choose的数据类型有一定要求：可以为byte、short、char、int、String、枚举，当然不同的JDK版本对switch影响不同。2.choose一般建议是变量，当然也可以是常量。而case后面的值为常量，并且choose与case的值的数据类型要一致。3.还记得每个case语句后的break吗？break表示退出此switch语句，如果没有break，则case语句会继续执行下去。 以上是switch比较重要的知识点，做一个简单的回顾。 接下来回顾下if语句 if语句if语句的样式就比较多了。if语句分为三种：简单if语句、双分支if语句、多分支if语句 简单if语句在代码中展示为：1234if(条件)&#123; 语句1&#125;语句2 大家可以直接从代码中看出来，简单if语句，也就只有if的存在，作为一个简单的判断，不管语句1执不执行，并不妨碍下方语句2的执行。 回顾了简单的if语句，接下来再说说双分支if语句 双分支if语句还记得什么是双分支if语句吗？是在简单if语句的基础上添加对立的条件else语句比如下面的代码：123456if(条件1)&#123; 语句1&#125;else&#123; 语句2&#125;语句3 通过条件1来判断是否需要执行语句1，如果条件1为真，则直接执行语句1；反之为假，则执行语句2。但是不管执行语句1或者语句2，语句3都会执行 双分支if语句中需要时刻了解其else的取值范围。 多分支if语句什么是多分支if语句呢？就是在if…else的基础上，再加入更多的条件进行选择。 12345678if(条件1)&#123; 语句1&#125;else if(条件2)&#123; 语句2&#125;else&#123; 语句3&#125;语句4 由于出现了一个else if，则每个判断的取值发生了变化，但在多分支if语句中，我们虽然可以像下面的代码一样添加更多的else if条件，但是选中的语句只会有一个，也就是说语句1、2、3只会有一个执行，谁先执行后面的就直接无效了，但并不影响语句4的执行。 12345678910if(条件1)&#123; 语句1&#125;else if(条件2)&#123; 语句2&#125;else if(条件3)&#123; 语句3&#125;else&#123; 语句4&#125;语句5 很多同学都已经掌握了上述的内容 接下来，来看一个不一样的if语句 双if语句什么是双if语句呢？1234567if(条件1)&#123;//第一个if语句 语句1&#125;if(条件2)&#123;//第二个if语句 语句2&#125;语句3 这个代码有点奇怪！一个代码中竟然连续出现多个if语句,那问题来了，到底执行哪一个if语句呢？答案是：都可能会执行，每个if语句间没有影响，不管是几个if语句，只要满足条件都会运行。 上述代码，条件1和条件2没有任何的关系，只要条件1满足就执行语句1，只要条件2满足就执行语句2，两者可能都会执行，当然，也可能都不执行；但请注意语句3一定会执行。 注意：不要把双if语句与多分支if语句傻傻分不清楚哟。 接下来进入我们的正题 switch和if else语句到底用谁上面对switch于if else语句进行了基本结构的回顾。 从基本结构也可以看出其区别： switch：主要是将choose中的值和某一个case值进行比较，而case值是一个确定的值。 if else：每个执行的语句前都会有一个条件，这个条件可以是类似x==0的这种匹配一个确定值的布尔表达式，也可以是x&gt;10的这种匹配一个范围的布尔表达式。 从它们的结构可以大致的分析出它们的用法区别，下面我们举几个例子来详细的表现出它们的区别。 例子1：将一个班级按照 0-59：E级 60-69：D级 70—79：C级 80—89：B级 90-100：A级的要求对输入的成绩进行等级评判 若使用if else语句 1234567891011121314151617181920Scanner sc = new Scanner(System.in);int x = sc.nextInt();//前两步骤是在获得输入值if(x&gt;=0&amp;&amp;x&lt;60)&#123;//注意，区间范围之间需要使用&amp;&amp;/||或者&amp;/|，来进行区间划分，而0&lt;=x&lt;60这种写法是禁止的 System.out.println("E级")；&#125;else if(x&gt;=60&amp;&amp;x&lt;69)&#123; System.out.println("D级")；&#125;else if(x&gt;=70&amp;&amp;x&lt;79)&#123; System.out.println("C级")；&#125;else if(x&gt;=80&amp;&amp;x&lt;89)&#123; System.out.println("B级")；&#125;else if(x&gt;=90&amp;&amp;x&lt;=100)&#123; System.out.println("A级")；&#125;else&#123;//当然，不能排除有些同学比较淘气，输入了小于0或者大于100的数据 System.out.println("输入有误")；&#125; 而使用switch来完成该代码呢？ 1234567891011121314151617181920212223Scanner sc = new Scanner(System.in);int x = sc.nextInt();//前两步骤是在获得输入值switch(x/10)&#123;//由于0-100之间有100个数据，用case来一个一个进行划分很麻烦，//所以先让x/10这样的话如:70-79的区间/10，则都为7 case 10://估计有同学会有疑问了，为什么10不做处理却要写出来呢？//原因是100/10等于10，所以有case 10选项，但是由于100和90-99的输出结果是相同的，//不写break，如果是100，则选择case 10，不输出，然后就直接执行case 9的语句，达到效果 case 9:System.out.println("A级")；break; case 8:System.out.println("B级")；break; case 7:System.out.println("C级")；break; case 6:System.out.println("D级")；break; case 5: case 4: case 3: case 2: case 1://上面怎么那么多case语句没有执行的语句呢？//和之间的case 10是一样的，case 5/4/3/2/1/0的效果都是一样的，都需要输出E级，//如果选中0，1,2,3,4,5某一个值，最后都会执行case 0的效果 case 0:System.out.println("E级")；break; default:System.out.println("输入有误")；&#125; 从上面可以看出，if else语句在这道题里用起来感觉挺顺手的，而switch呢？就要复杂得多了。 我们再来看一个例子 例2：给出如下选项，并根据选项进行效果展示：输入1：则输出“普通攻击”；输入2：则输出“魔法攻击”；输入3：则输出“使用道具”；输入3：则输出“逃跑”； 当然，这道题更多出现在游戏的内容中 那如果我们使用if else语句该如何书写呢？ 12345678910111213Scanner sc = new Scanner(System.in);int x = sc.nextInt();//前两步骤是在获得输入值if(x==1)&#123; System.out.println("普通攻击")；&#125;else if(x==2)&#123; System.out.println("魔法攻击")；&#125;else if(x==3)&#123; System.out.println("使用道具")；&#125;else if(x==4)&#123; System.out.println("逃跑")；&#125;else&#123;//当然，依然会有同学比较淘气，不按常理出牌 System.out.println("输入有误")；&#125; 而使用switch语句呢？ 123456789Scanner sc = new Scanner(System.in);int x = sc.nextInt();//前两步骤是在获得输入值switch(x)&#123; case 1:System.out.println("普通攻击")；break; case 2:System.out.println("魔法攻击")；break; case 3:System.out.println("使用道具")；break; case 4:System.out.println("逃跑")；break; default:System.out.println("输入有误")；&#125; 从这个例子可以看出：switch写起来要比if else更为简洁，并且使用x==0这些方式写出来，难免感觉怪怪的。 综上两道题可以看出：switch更适用于有确切值的选择，而if else更适合用于进行范围判断的内容。 当然上述两道题可以互相转换，也就是说到底使用switch还是if else并没有严格要求，在恰当的地方使用恰当的方法是每个程序员需要深思熟虑的。 当然我们的讨论还没有结束，上面只是从例子说明了switch与if else的区别，接下来我们从它们的执行效率上来进行讲解。 switch与if else的执行效率单从JVM的执行效率上讲的话,switch的执行效率要高于if语句： 原因在于:switch语句在运行时，首先会生成一个“跳转表”来指示实际的case分支的地址，而这个“跳转表”的索引号与swtich中的case值是相等的，这样的话，switch就不用像if else那样，遍历所有的条件，直至找到正确条件，而仅仅只需要访问对应索引号的表项就可以到达定位分支的目的。 简单的说，switch会生成一个数据统计表，将case后面的值全部统计起来，匹配时先拿表中的数据进行比较，如果有则直接跳转到相应case语句；如果没有，则直接跳转到default语句。 那if else呢？其实刚刚我们已经简单的说了其工作流程，这里再次说明一下： if else语句需要一条一条的去进行取值范围的判断，直到找到正确的选项位置，这样的话势必会浪费大量的时间。 所以，单从其运行的效率来看，switch语句要更胜一筹。 总结这里简单的总结一下： 1.switch语句由于它独特的case值判断方式，使其执行效率更高，而if else语句呢，则由于判断机制，导致效率稍慢。 2.到底使用哪一个选择语句，和当前的代码环境有关，如果是范围取值，则使用if else语句更为快捷；如果是确定取值，则使用switch更是一个不错的选择。 所有好的程序都是经过不断思考，不断琢磨，付出努力，最终得以完成的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java的安装与环境变量设置]]></title>
    <url>%2F2017%2F06%2F07%2F20170607%2F</url>
    <content type="text"><![CDATA[java的安装与环境变量设置要学习java,至少需要先将java安装到系统中,而且需要配置好必要的环境变量,java才能更好的工作。 下载要安装当然至少需要先下载,你可以直接进入如下网址直接下载最新版本的JDK版本 最新版本的JDK下载地址 进入网页之后,你会看到这样的界面: 直接图中点击箭头指示的JDK,进入如下界面,注意箭筒指示,点击同意下载协议才能开始下载 我们一般都使用的是windows系统,当然下载选择就之后下面的 windows X86与windows X64版本两个 windows X86 对应 windows32位的系统 windows X64 对应 windows64位的系统 这个就需要根据你自己windows的系统进行选择了 现在就可以直接点击下载了…java是免费下载的,不过Oracle公司会在你下载的时候,提示你注册登录,如果你想下载的话…就必须先注册一个Oracle公司的账号…这个无所谓…随便注册一个就可以开始下载了 安装java的安装其实很简单,直接下一步下一步就可以完成,不过需要注意下面两个重要问题: 1.不要安装在带中文路径的目录下面比如类似于: d:\软件 2.最好不要安装在带空格的目录下面比如类似于: c:\Program Files 而且,我们的下载的JDK软件,其实会安装2个东西,一个是JDK,一个是JRE JDK其实就是java development kit,java开发工具包 JRE是java runtime environment,java运行时环境 简单来说,两个东西都是我们必须的,根据中文的意思,我们开发当然使用JDK,如果只是需要运行的话就可以使用JRE,其实这个并不需要纠结,大家都安装好就行了,主要是后面需要配置环境变量的时候需要注意…我们是要用java做开发,所以,一定要配置JDK的路径 如果大家对安装有疑问的话,下面是安装步骤的截图,没有疑问就把这里直接跳过 1.进入安装(注意现在安装的是JDK)注意红框的地方,这里的地址我们最好改变一下…因为默认安装在带空格的Program Files的目录下面 2.点击更改,修改安装目录我这里是直接安装在c盘java目录下 3.JDK安装 4.弹出JRE的安装地址提示注意在安装过程中就会弹出提示框,现在是让你安装JRE了,同样最好改变安装路径地址,而且最好和JDK安装在同一个目录下面 5.最好在JDK同路径下,新建一个JRE安装目录,将JRE安装在该目录下注意我这里是在c盘-&gt;java目录下,新建了一个文件夹,取名为jre1.8.0_131,和之前安装的jdk1.8.0_131在同一路径在最好修改后的路径: 7.进行最后的安装 java的配置首先,我们可以进入jdk的安装目录的bin路径下,你会发现,这里有很多exe可执行文件,现在对我们最重要的是一个java.exe与javac.exe文件我们并不能直接单击他们时候,只能在DOS命令行窗口中,通过键入这两个命令来进行使用 打开DOS命令行窗口在windows7中,在附件中,找到运行在打开的运行窗口中,输入cmd,打开dos命令行 当然,你也可以直接按快捷键 windows标志键 + R 直接打开运行窗口 运行javac命令在打开的DOS命令行中输入JDK,bin目录地址,如下图: 回车,就会进入该目录,在该目录中运行javac命令,如下图:如果出现下面的效果,证明JDK的安装就没有啥大问题了… 但是,现在还存在的一个问题是,只有在C:\Java\jdk1.8.0_131\bin这个目录下,javac命令才会有效果,如果在其他目录,比如C盘根目录,运行javac就不行,如下图: 因此,如果想要javac比较方便在命令行窗口运行,就需要配置环境变量 配置java环境变量进入windows系统界面,点击高级系统设置 点击环境变量 在下面的系统变量中,找到Path选项,点击编辑 在出现的窗口中,输入jdk的bin路径C:\Java\jdk1.8.0_131\bin注意,在路径前一定要加上分号; 一路点击确定,再次重新打开命令行窗口,现在,我们在任意的地址都可以输入javac命令来进行测试了]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[认识计算机硬件]]></title>
    <url>%2F2017%2F06%2F04%2F20170604%2F</url>
    <content type="text"><![CDATA[我要学编程:我叫周大牛，或许你会想到一个卖手链、吊坠什么的一个叫周大福的人，没错，我们仅仅是名字相似而 已。我一直很讨厌被别人联想我和他之间关系的原因在于他永远比不上我的帅气：先做个自我介绍：20岁之前我是一个网管，年纪轻轻就月入2000，掌管整个网吧30台电脑，不管初中还是高中的小孩见我都要叫一声周哥，连吃泡面都要加两个蛋，穿鞋只穿李宁，而且一定要福建产的。曾经我一度是我们村唯一的希望。村花小美从小就崇拜我，整个城乡结合部一致认为小美一定是我的女人，直到21岁生日那天我看到小美上了我头上的那个男人(网吧老板)的车:那一刻开始，我发誓我要出去闯出自已的事业(其实是老板让我滚蛋)。那是我离开家乡的第15天，我依旧来到临时工市场，穿着我帅气的拖鞋，在我的心里默默给自己加油：看了那么多小说，男主落难的时候一定会出现白富美哭着喊着求约。我的白富美，你快出现啊，再不出现我可吃不起晚饭了。 这个时候，那个男子终于出现了，我永远忘记不了这一刻，我的人生就这样被他改变了： 至于原因嘛:他告诉我，通过这本书你可以拥有很多很多对象，用一个换一个。善良的我最后用25块钱买下了这本书，为什么这么便宜，因为书上很多地方都有像血一样的痕迹，他告诉我这是以前买这本书的人激动的喷血，给你这么便宜因为不再接受退货了。就这样，最终我走向了学习程序的道路 我要买电脑:以前我一直是我们乡村结合部的电脑高手，熟悉各种电脑的开关机。但是买电脑还是第一次，总不能去以前的网吧向那个和我有夺妻之恨的人借吧，不行我要买一台属于自己的电脑，免得和以前一样公用电脑，导致我的很多电影被人误删了(我的葫芦娃全集就这样离我而去)。说干就干，明天就去电脑城，今晚回去把家里的牛卖掉换钱，这样就可以完成走向人生巅峰的第一步了。。。 电脑城艳遇:看来老头说的没错，写程序果然会走上人生巅峰，买电脑都能遇到比小美还要漂亮的，莫非她就是上天给我的安排？看来这条路选对了，暗暗为自己点个赞。拿出我500块钱买的苹果6，换了块电池(外国手机就是费电)，赶紧偷偷拍一张： 整理了一下我那件才穿几十次的条纹衬衣，用最霸道方式走向了她，在她惊讶的注释下，我无比优越的说：给我买台电脑，私人电脑，如果你想要我的电话也行。我偷偷看了下她胸口的吊牌，上边写着她的名字:苍小优。 小苍老师带你学:苍小优：好的帅哥(看看，果然大城市的美女才能品味出我独特的帅气)，请问你是买品牌机还是自己DIY呢？ 周大牛：。。。D啥Y，这是个什么东西，你能不能解释一下。 苍小优：DIY是英文Do It Yourself的缩写，可以正式译为自己动手做，一般对电脑熟悉的人都是自己购买电脑的硬件然后组装在一起，当然这可能存在电脑硬件兼容性问题，不过一般只要你告诉销售人员你电脑其他硬件，他们会帮你参考解决兼容性问题。当然如果你不了解电脑的话也可以购买整体电脑，就是我们说的品牌机。 周大牛：我可是要成为程序员的男人，必须D个Y，不过小姐姐你可不可以给我仔细讲解下我需要购买哪些硬件呢，玩游戏我在行，可是电脑的这些东西我是都不认识。 苍小优：没问题程序员先生，那我现在就给你讲讲计算机硬件的组成，首先我们我们必须认识CPU，这个可是计算机最核心的东西: 中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。 再通俗的说呢：CPU就是电脑的中央处理器,就好比人的心脏.你的计算机要做什么事情都是由它去发布命令。所以呢，这也是购买电脑的时候的一个主要开销了。目前CPU最大的两个品牌分别是Intel和AMD，等下你可以在它们之间根据喜好购买 接着呢我们来认识下一个非常厉害的东东：内存 内存(Memory)是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大计算机运行程序的时候，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来，内存的运行也决定了计算机的稳定运行 目前市场上流行的计算机内存的生产厂商有金士顿、现代、三星、威刚等。当然如果你平时如果对电脑反应速度快点的话可以购买一些比较大的内存，目前比较多的选择是8G、16G，当然如果有需要可以购买多个内存条让你电脑运行更快，而且内存的价格没有CPU那么贵哦。 接着我们再看电脑下一个必需品：硬盘 硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料，平时你存放在电脑上的资料其实都在这里边，注意：CPU和内存都是运行软件的地方，真正存储资料的地方在硬盘中 硬盘呢有很多种类，主要有这几种：固态硬盘（SSD）、机械硬盘（HDD ）、混合硬盘（HHD 一块基于传统机械硬盘诞生出来的新硬盘）； 其中ssd里面是由闪存颗粒组成的 读取速度要比HDD快的多 但是使用寿命的话ssd没有hdd这么久 他的读取次数是有限的 还有就是目前ssd价格较高 目前来看还是用HDD比较划算。 这个呢，就是大名鼎鼎的主板，刚才我们所说的CPU,内存，硬盘什么的为了统一管理，我们把它们全部安装到主板上，这样它们之间就能共同合作，完成你所要完成的所有事情了 主板（英语：Motherboard,Mainboard，简称Mobo）供处理器、显卡、声效卡、硬盘、存储器、对外设备等设备接合 目前比较流行的主板的品牌有：华硕（ASUS） 技嘉（GIGABYTE） 微星（MSI）等，主板的价格也稍微贵一点，同样也是你购买计算机的时候主要的开销之一 当然咯，主板上这么多插口到底做什么用的呢，除了方才我们所说的这些必需品(cpu、内存、硬盘)之外，如果你对电脑音质和画质有高品质要求，你可以购买单独的声卡和显卡(如果打游戏必备)。 声卡 (Sound Card)也叫音频卡（港台称之为声效卡），是多媒体技术中最基本的组成部分，是实现声波/数字信号相互转换的一种硬件。声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口(MIDI)使乐器发出美妙的声音 显示接口卡（Video card，Graphics card），又称为显示适配器（Video adapter）显卡的用途是将计算机系统所需要的显示信息进行转换驱动显示器，并向显示器提供行扫描信号，控制显示器的正确显示，是连接显示器和个人电脑主板的重要元件，是“人机对话”的重要设备之一。 当然如果不购买也没关系，主板上有集成的声卡和显卡，当然效果就没那么好了 接下来，我们刚才列举的这些计算机必备品，我们需要找个东西把它们集中管理装起来，那就是我们的主机箱咯： 机箱作为电脑配件中的一部分，它起的主要作用是放置和固定各电脑配件，起到一个承托和保护作用，此外，电脑机箱具有电磁辐射的屏蔽的重要作用，由于机箱不像CPU、显卡、主板等配件能迅速提高整机性能，所以在DIY中一直不被列为重点考虑对象。 我们将刚才的硬件全部按照说明安装到主机箱里边就可以正常工作了。主机箱的价格比较便宜。所以选择一个你喜欢样子的主机箱吧。 当然要启动你的电脑还需要一个必须用品，那就是电源： 电脑电源是把220V交流电，转换成直流电，并专门为电脑配件如CPU、主板、硬盘、内存条、显卡、光盘驱动器等供电的设备，是电脑各部件供电的枢纽，是电脑的重要组成部分。目前PC电源大都是开关型电源。 同样的电源价格也不是很贵，但我们需要选择一个比较大的品牌，质量过关的电源才可以，目前市场上大品牌主要有 航嘉 | 鑫谷 | aigo | 金河田 | 先马 | 长城机电 | Tt | 安钛克 等 这样一台电脑基本上核心部分就完成了，剩下的就不需要太多解释了，每个使用电脑的人都知道还有这些需要配置的： 显示器 显示器有贵的有便宜的，价格相差比较大，你可以选择普通偏上的1000-1500左右的就可以了，目前主流品牌有：AOCSamsung/三星飞利浦Benq/明基Dell/戴尔HKC/惠科等 鼠标、键盘 顺手的鼠标键盘能让你事半功倍，当然也不需要苛求太好了，价格也不是很贵，几百块钱之内就能买到很好的键盘鼠标了 有了这些东西，一台计算机就算配完了，当然了，音箱什么的你可以以后慢慢自己配置了 现在我就带你去购买这些东西吧。。。 又一名程序员:最终我花了5000块钱购买了电脑，并且顺利约小优导购一起吃了闻名中外的开封菜，并且得到了她的QQ号码。从明天起，我就要成为程序员的男人了，努力啊，奋斗啊！！]]></content>
      <categories>
        <category>计算机常识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为什么老鸟要告诉你优先使用组合而不是继承？]]></title>
    <url>%2F2017%2F06%2F01%2F20170601%2F</url>
    <content type="text"><![CDATA[大家知道，面向对象有三个特征：继承、封装和多态。现在，我们谈谈关于继承的一些问题。了解一下继承的优点、缺点，以及继承缺点的解决方案。 继承的起源，来自于多个类中相同特征和行为的抽象。子类可以通过继承父类，那么可以调用父类中定义的方法和属性，从而达到代码重用的目的。另外，子类除了重用父类的代码以外，还可以扩展自身的属性和方法，来描述子类特有的特征和行为。 例如：人类和马类这两个类，有什么共同的特征和行为呢？都有年龄，都要呼吸，都可以行动，都要吃奶。我们可以把人类和马类相同的特征和行为抽取出来，形成一个父类：哺乳动物。人类和马类只要继承哺乳动物这个父类。那么，就可以直接重用哺乳动物父类中定义的属性和行为，相同的属性和行为就可以不用再重复描述。所以，通过继承，可以达到代码很大的重用。 除此之外，人类和马类还可以再定义自己本身的特征和行为。比如，马要吃草，人可以说话。那么，人类和马类可以在继承了哺乳动物父类的同时，再定义说话或吃草的行为，来扩展自身的特征和行为。 123456789101112131415161718class Mammal&#123; private int age; public void breath()&#123;&#125;&#125;class ManKind extends Mammal &#123; public void speak()&#123;&#125;&#125;……ManKind m = new ManKind();m.spaeak();//本类中定义的方法m.breath();//父类中继承的方法 使用继承有很多优点，父类的大部分功能可以通过继承关系自动进入子类；修改或扩展继承而来的属性和方法较为容易。那么，如何判断两个类之间是否有继承关系呢？很简单，用”是”来判断。比如：马是动物。那么马继承于动物。玫瑰是植物。那么玫瑰继承于植物。骂人的时候，我们会说：你是畜牲，那么这个人继承于畜牲，象畜牲一样没有人性。你是猪，那么这个人继承于猪，象猪一样愚笨。这就是所谓的”is-a”。 但是，继承同样有很多缺点。人类在大千世界中，不断的认识世界，也不断的改造世界。人类曾经梦想，在天空中飞翔。那么，人类如何飞行呢？鸟可以飞行，那是因为鸟有翅膀这个特征，才会拥有飞这个行为。如果人类继承于鸟类，象鸟一样长出翅膀，那么也就可以有飞行的行为了。 《封神榜》中的雷震子和天使，其实就是人类想在天空中飞行的一种想法。那就是继承鸟这个类，拥有鸟类的翅膀和飞行的行为。 那么，人类想下海应该怎么办呢？于是人类又在想，只要将人类继承于鱼类，拥有鱼的尾巴，那么就可以下海了。随着这种想法的产生，美人鱼就出现了。 那么，如果人类既想飞行，又想下海应该怎么办呢？有人说，那还不简单，把人类同时继承于鸟类和鱼类不就行了吗。但是，不好意思，在java中，类只能单根继承。也就是说，一个类只能有一个父类，不能同时继承两个父类。所以，从这里就可以看出继承的其中一个缺点：无法通过继承的方式，重用多个类中的代码。 除此之外，继承还有第二个缺点，那就是，父类的属性和方法，子类是无条件继承的。也就是说，不管子类愿意不愿意，都必须继承父类所有的属性和方法。比如，每个人都有自己父母，如果父母比较富有，那么子女就吃得好穿得好。如果父母是穷人，那么子女吃不饱穿不暖。很显然，所有的人都希望自己是富二代，官二代，而不想成为穷二代。不过，人是无法选择自己父母的。所以，父母的一切，自己是无条件接受的。 同样道理，如果人类继承于鸟类，我们希望拥有的是：鸟的翅膀和飞的行为。但是，鸟还有吃虫的行为，鸟还有下蛋的行为。这些是我们不希望拥有的。不过，如果人类继承于鸟类的话，那么吃虫和下蛋的行为，人类就得无条件接受了。所以，使用继承很容易造成方法的污染。一旦父类的属性和方法，在子类中不能完全适用。那么，也就不应该使用继承关系了。 1234567891011121314class Bird&#123; public void fly()&#123;&#125; public void layEggs()&#123;&#125;&#125;class ManKind extends Bird&#123; public void speak()&#123;&#125;&#125;……ManKind m = new ManKind();m.spaeak();m.fly();//人类希望拥有的飞行行为m.layEggs();//人类不希望拥有的下蛋行为 还有，从父类继承而来的实现是静态的，不能在运行时发生改变，不够灵活。比如，有一个人从春熙路到天府广场去。 123456789101112class Man&#123; public void run()&#123; System.out.println("前往天府广场"); &#125;&#125;class CDMan extends Man&#123;&#125;……CDMan c = new CDMan();c.run(); 当我们调用run()方法时，就只能打印从父类中继承的run方法。如果这个人想骑单车去天府广场应该怎么办呢？有人说，简单，在CDMan中重写run()不就行了吗？ 123456class CDMan extends Man&#123; @Override public void run()&#123; System.out.println("骑单车去天府广场"); &#125;&#125; 但是，如果这个人想骑单车走一段，再开汽车走一段，就没法通过继承和重写来实现了。所以，无论是从父类中继承的方法，还是子类重写的父类方法，实现的都是一种静态的复用。不能在运行时发生改变，灵活性比较差。 那么，如何解决继承的这些缺点呢？荀子在《劝学》中，有这样的一段话：”假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。”就是说，人可以骑马，即使这个人跑得不快，也可以到达千里之外。人可以坐船，即使这个人不会游泳，也可以到达江河的任何位置。君子其实没什么太多特别的地方，只不过善于利用工具而已。这就是所谓的”has-a”。拥有什么，或者使用什么。 荀子的这段话，指出了解决继承缺陷办法，那就是使用聚合/组合达到代码的复用。比如，人想上天怎么办呢？可以利用飞机上天。人想下海怎么办呢，可以利用轮船下海。并不要求人要长出翅膀，人要长出鱼尾。 这样的解决方案，其实就是告诉我们，与其我们”是什么”，倒不如我们”用什么”。也就是用聚合/组合复用，去代替继承复用。把一些特征和行为抽取出来，形成工具类。然后通过聚合/组合成为当前类的属性。再调用其中的属性和行为达到代码重用的目的。 换句话说，用”has-a”(有什么或用什么)去替代”is-a”(是什么)。 12345678910111213141516class Plane&#123; public void fly()&#123;&#125;&#125;class Ship&#123; public void swim()&#123;&#125;&#125;class ManKind &#123; private Plane p = new Plane(); private Ship s = new Ship(); public void fly()&#123; p.fly(); &#125; public void swim()&#123; s.swim(); &#125;&#125; 从以上代码可以看出，通过聚合/组合关系，可以解决继承的缺点。由于一个类可以建多个属性，也就是可以聚合多个类。所以，可以通过聚合/组合关系，重用多个类中的代码。 另外，我们可以选择一个类中是否应该具有某种行为，从而决定应该聚合那些类，不应该聚合那些类。这样，通过聚合/组合关系，也可以避免继承所带的方法污染问题。所以，使用聚合/组合，具有很强的代码重用性和灵活性。 聚合/组合复用也可以在运行时动态进行。新对象可以使用聚合/组合关系，将新的责任委派到合适的对象。 123456789101112131415161718192021222324252627282930313233343536//交通工具接口interface Vehicle&#123; public void run();&#125;//自行车实现类class Bike implements Vehicle&#123; public void run()&#123; System.out.println("骑单车行走"); &#125;&#125;//汽车实现类class Car implements Vehicle&#123; public void run()&#123; System.out.println("开汽车行走"); &#125;&#125;//人类class CDMan &#123; private Vehicle v; public void run()&#123; v.run(); &#125;//更换交通工具 public void changeVehicle(Vehicle v)&#123; this.v = v; &#125; &#125;……CDMan c = new CDMan();c.changeVehicle(new Bike());c.run();//骑单车行走c.changeVehicle(new Car());c.run();//开汽车行走 从这里可以看出，人类可以随时改换交通工具，达到行走的目的。这种方式可以在运行期间，随时改变接口属性的实现类。从而调用不同实现类描述的具体方法，灵活性很强。 总结： 继承和聚合/组合都可以达到代码重用的目的。继承有自身的优点，父类的大部分功能可以通过继承关系自动进入子类；修改或扩展继承而来的实现较为容易。 但是，继承同样有缺点， 无法通过继承达到多个类代码的重用。 父类的方法子类无条件继承，很容易造成方法污染。 从父类中继承的方法，是一种静态的复用。不能在运行时发生改变，不够灵活。 继承可以用，但使用继承需要谨慎。一般来说，使用继承有两个条件： 父类中所有的属性和方法，在子类中都适用。 子类不需要再去重用别的类中的代码。如果不能满足这两个条件，那么就应该使用聚合/组合关系去替代继承，来达到代码的复用。]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[别被final、finally和finalize这三兄弟给骗了，其实它们半毛钱关系也没有]]></title>
    <url>%2F2017%2F05%2F27%2F20170527%2F</url>
    <content type="text"><![CDATA[Java的这三个兄弟final、finally和finalize，你别说，他们三个看起来还真像，不把眼睛睁大点还真分辨不出来。难怪在Java面试时，面试官就喜欢拿来糊弄我们这些Java菜鸟。 最近小马云在网上火了，马云凭空多出来一个儿子，也真够衰的，哈哈。我还真百度搜了一下马云的真儿子，叫马元坤；估计比较低调，不像王思聪深怕没人知道他老爸就是王健林。这娃一看就是一枚小鲜肉，还好长得一点都不像他老爸，不然肯定会误认为是“孙悟空转世”。 还是回过头来，看一下我们Java的这三个假兄弟final、finally和finalize。你别说，他们三个看起来还真像，不把眼睛睁大点还真分辨不出来。难怪在Java面试时，面试官就喜欢拿来糊弄我们这些Java菜鸟。 你老说它们半毛钱关系也没有，那么他们究竟是哪里来的？别着急！我们马上就让这三兄弟各回各家，各找各妈。 finalfinal从字面上理解含义为“最后的，最终的”。在Java中也同样表示出此种含义。 final可以用来修饰变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类。 final修饰类 final修饰类即表示此类已经是“最后的、最终的”含义。因此，用final修饰的类不能被继承，即不能拥有自己的子类，俗称“太监类”。如果试图对一个已经用final修饰的类进行继承，在编译期间就会发生错误。 123final class User &#123; //被final修饰的类不能被继承 …&#125;那有哪些类是太监类呀？String就是一个被final修饰的类，我们只能用，不能继承。 2. final修饰方法 final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即此方法不能被重写（可以重载多个final修饰的方法）。 此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。1234567891011121314151617181920public class B extends A &#123; public static void main(String[] args) &#123; &#125; public void getName() &#123; &#125;&#125; class A &#123; //因为private修饰，子类中不能继承到此方法。 //因此，子类中的getName方法是重新定义的、 属于子类本身的方法 private final void getName() &#123; //编译正常 &#125; //因为public修饰，子类可以继承到此方法，导致重写了父类的final方法 public final void getName() &#123; //编译出错 &#125;&#125; 3. final修饰变量 final修饰的变量表示此变量是“最后的、最终的”含义。一旦定义了final变量并在首次为其显示初始化后，final修饰的变量值不可被改变。 final修饰的实例变量 被final修饰的实例变量必须显示指定初始值，而且只能在如下3个位置指定初始值： 1.定义final实例变量时指定初始值； 2.在非静态初始化块中为final实例变量指定初始值 3.在构造器中为final实例变量指定初始值 对于普通实例变量，Java程序可以对它执行默认的初始化，也就是将实力变量的值指定为默认的初始值0或null，但对于final实例变量，则必须由程序员显示指定初始值。 final实例变量必须显示地被赋初始值，而且本质上final实例变量只能在构造器中被赋初始值。在定义final实例变量时指定初始值，和在初始化块中为final实例变量指定初始值本质上是一样的。除此之外，final实例变量将不能被再次赋值。 final修饰的类变量 对于final类变量而言，同样必须显示指定初始值，而且final类变量只能在2个地方指定初始值： 1.定义final类变量时指定初始值； 2.在静态初始化块中为final类变量指定初始值； 这两种方式都会被抽取到静态初始化块中赋初始值。定义final类变量时指定初始值和在静态初始化块中为final类变量指定初始值，本质是一样的。除此之外final类变量将不能被再次赋值。 final修饰局部变量 final修饰的局部变量一样需要被显式地赋初始值，因为Java本来就要求局部变量必须被显式地赋初始值。与普通变量不同的是，final修饰的局部变量被赋初始值之后，将不能再被重新赋值。 final修饰符的第一简单的功能就是一旦被赋初始值，将不可改变。final的另一个简单的功能就是在定义了该final类变量时指定了初始值，且该初始值可以在编译时就被确定下来，系统将不会在静态初始化块中对该类变量赋初始值，而将是在类定义中直接使用该初始化值代替该final变量。 对于一个使用final修饰的变量而言，如果定义该final变量时就指定初始值，而且这个初始值可以在编译时就确定下来，那么这个final变量将不再是一个变量，系统会将其变成“宏变量”处理。所有出现该变量的地方，系统将直接把它当成对应的值处理。 执行“宏替换”的变量 对于一个final变量，不管它是类变量、实例变量还是局部变量，定义了该变量时使用了final修饰符修饰，并在定义该final类变量时指定了初始值，而且该初始值可以在编译时就被确定下来，那么这个final变量本质上已经不再是变量，而是想当于一个直接的变量。 final修饰符的一个重要用途就是定义“宏变量“，当定义final变量时就为该变量指定了初始值，而且该初始值可以在编译的时候就确定下来，那么这个final变量本质上就是一个”宏变量“，编译器会把程序中所用到该变量的地方直接替换成该变量的值。如果被赋的表达式只是基本的算术运算表达式或字符串连接运算，没有访问普通变量，调用方法，Java编译器同样会将这种final变量当成”宏变量“处理。 对于实例变量而言，可以在定义该变量时赋初始值之外，还可以在非静态初始化块、构造器中对它赋初始值，在这三个地方指定初始值的效果基本一样。但对于final实例变量而言，只有在定义该变量时指定初始值才会有”宏变量“的效果，在非静态初始化块、构造器中为final实例变量指定初始值则不会有这种效果。对于普通类变量而言，在定义时指定初始值，在静态初始化块中赋初始值的效果基本一样。但对于final类变量而言，只有在定义final类变量时指定初始值，系统才会对该final类变量执行”宏替换“ 内部类中的局部变量 不仅匿名内部类，即使是普通内部类，在任何内部类中访问的局部变量都应该使用final修饰。 此处说的内部类指的是局部内部类，只有局部内部类（包括匿名内部类）才可以访问局部变量，普通静态内部类、非静态内部类不可能访问方法体内的局部变量。Java要求所有被内部类访问的局部变量都使用final修饰，对于普通局部变量而言，它的作用域就是停留在该方法内，当方法执行结束，该局部变量也随之消失。但内部类则可能产生隐式的”闭包“闭包将使得局部变量脱离它所在的方法继续存在。 匿名内部类的实例生命周期没有结束的话，将一直可以访问局部变量的值，这就是内部类会扩大局部变量作用域的实例。由于内部类可能扩大局部变量的作用域，如果再加上这个被内部类访问的局部变量没有使用final修饰，也就是说该变量的值可以随意改变，就会引起大乱。因此Java编译器要求所有被内部类访问的局部变量必须使用final修饰。 finally finally从字面上理解含义为“最后的；决定性地；最终的”。在Java中的finally关键字一般与try/catch一起使用，如下图： 在程序进入try块之后，无论程序是因为异常而中止或其它方式返回终止的，finally块的内容一定会被执行，还是写个例子来说明下1234567891011121314151617181920212223242526272829303132public class TryAndFinallyTest &#123; public static void main(String[] args) throws Exception&#123; try&#123; int a = testFinally(2); System.out.println("异常返回的结果a:"+a); &#125;catch(Exception e)&#123; int b = testFinally(1); System.out.println("正常返回的结果b:"+b); &#125; int b = testFinally(3); System.out.println("break返回的结果:"+b); b = testFinally(4); System.out.println("return返回的结果:"+b); &#125; static int testFinally(int i) throws Exception&#123; int flag = i; try&#123; //一旦进去try范围无论程序是抛出异常或其它中断情况， //finally的内容都会被执行 switch(i)&#123; case 1:++i;break;//程序 正常结束 case 2:throw new Exception("测试下异常情况"); case 3:break; default :return -1; &#125; &#125;finally&#123; System.out.println("finally coming when i="+flag); &#125; return i; &#125;&#125; 执行结果如下: finally coming when i=2 finally coming when i=1 正常返回的结果b:2 finally coming when i=3 break返回的结果:3 finally coming when i=4 return返回的结果:-1 结果说明无论上述什么情况，finally块总会被执行。 与其他语言的模型相比，finally 关键字是对 Java 异常处理模型的最佳补充。finally 结构使代码总会执行，而不管有无异常发生。使用 finally 可以维护对象的内部状态，并可以清理非内存资源。 如果没有 finally，您的代码就会很费解。 例如，下面的代码说明，在不使用 finally 的情况下您必须如何编写代码来释放非内存资源：123456789101112131415161718import java.net.*; import java.io.*;public class WithoutFinally &#123; public void foo() throws IOException &#123; //在任一个空闲的端口上创建一个套接字 ServerSocket ss = new ServerSocket(0); try &#123; Socket socket = ss.accept(); //此处的其他代码... &#125;catch (IOException e) &#123; ss.close(); //1 throw e; &#125; //... ss.close();//2 &#125;&#125; 这段代码创建了一个套接字，并调用 accept 方法。在退出该方法之前，您必须关闭此套接字，以避免资源漏洞。为了完成这一任务，我们在 //2 处调用 close，它是该方法的最后一条语句。 但是，如果 try 块中发生一个异常会怎么样呢？在这种情况下，//2 处的 close 调用永远不会发生。因此，您必须捕获这个异常，并在重新发出这个异常之前在 //1 处插入对 close 的另一个调用。这样就可以确保在退出该方法之前关闭套接字。 这样编写代码既麻烦又易于出错，但在没有 finally 的情况下这是必不可少的。不幸的是，在没有 finally 机制的语言中，程序员就可能忘记以这种方式组织他们的代码，从而导致资源漏洞。Java 中的 finally 子句解决了这个问题。有了 finally，前面的代码就可以重写为以下的形式：1234567891011121314import java.net.*;import java.io.*;public class WithoutFinally &#123; public void foo() throws IOException &#123; //在任一个空闲的端口上创建一个套接字 ServerSocket ss = new ServerSocket(0); try &#123; Socket socket = ss.accept(); //此处的其他代码... &#125; finally &#123; ss.close(); &#125; &#125;&#125; finally 块确保 close 方法总被执行，而不管 try 块内是否发出异常。因此，可以确保在退出该方法之前总会调用 close 方法。这样您就可以确信套接字被关闭并且您没有泄漏资源。 在此方法中不需要再有一个 catch 块。在第一个示例中提供 catch 块只是为了关闭套接字，现在这是通过 finally 关闭的。如果您确实提供了一个 catch 块，则 finally 块中的代码在 catch 块完成以后执行。 finally 块必须与 try 或 try/catch 块配合使用。此外，不可能退出 try 块而不执行其 finally 块。如果 finally 块存在，则它总会执行。 那有没有办法退出try而不执行finally块？答案是：有 如果代码在 try 内部执行一条 System.exit(0); 语句，则应用程序终止而不会执行 finally 执行。 如果您在 try 块执行期间快速拨掉电源，finally 也不会执行。 finalize finalize从字面上理解含义为“完成; 使结束; 使落实;”。Java的垃圾回收器要回收对象的时候，首先要调用这个类的finalize方法。 一般的纯Java编写的Class不需要重新覆盖这个方法，因为Object已经实现了一个默认的，除非我们要实现特殊的功能(这 里面涉及到很多东西，比如对象空间树等内容)。 不过用Java以外的代码编写的Class(比如JNI，C++的new方法分配的内存)，垃圾回收器并不能对这些部分进行正确的回收，这时就需要我们覆盖默认的方法来实现对这部分内存的正确释放和回收(比如C++需要delete)。 总之，finalize相当于析构函数，它是垃圾回收器回收一个对象的时候第一个要调用的方法。不过由于Java的垃圾回收机制能自动为我们做这些事情，所以我们在一般情况下是不需要自己来手工释放的。 有时当撤消一个对象时，需要完成一些操作。例如，如果一个对象正在处理的是非Java 资源，如文件句柄或window 字符字体，这时你要确认在一个对象被撤消以前要保证这些资源被释放。为处理这样的状况，Java 提供了被称为收尾（finalization ）的机制。使用该机制你可以定义一些特殊的操作，这些操作在一个对象将要被垃圾回收程序释放时执行。 要给一个类增加收尾（finalizer ），你只要定义finalize ( ) 方法即可。Java 回收该类的一个对象时，就会调用这个方法。在finalize ( )方法中，你要指定在一个对象被撤消前必须执行的操作。垃圾回收周期性地运行，检查对象不再被运行状态引用或间接地通过其他对象引用。就在对象被释放之 前，Java 运行系统调用该对象的finalize( ) 方法。 12345//finalize()方法的通用格式如下protected void finalize( ) &#123; // finalization code here&#125; 其中，关键字protected是防止在该类之外定义的代码访问finalize()标识符。 理解finalize( ) 正好在垃圾回收以前被调用非常重要。例如当一个对象超出了它的作用域时，finalize( ) 并不被调用。这意味着你不可能知道何时——甚至是否——finalize( ) 被调用。因此，你的程序应该提供其他的方法来释放由对象使用的系统资源，而不能依靠finalize( ) 来完成程序的正常操作。 注意：如果你熟悉C++，那你知道C++允许你为一个类定义一个撤消函数（destructor ），它在对象正好出作用域之前被调用。Java不支持这个想法也不提供撤消函数。finalize() 方法只和撤消函数的功能接近。当你对Java 有丰富经验时，你将看到因为Java使用垃圾回收子系统，几乎没有必要使用撤消函数。 finalize的工作原理是这样的： 一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存.所以如果使用finalize()，就可以在垃圾收集期间进行一些重要的清除或清扫工作. finalize()在什么时候被调用?有以下三种情况： 1.所有对象被Garbage Collection（垃圾回收器）时自动调用,比如运行System.gc()的时候. 2.程序退出时为每个对象调用一次finalize方法。 3.显式的调用finalize方法 除此以外,正常情况下,当某个对象被系统收集为无用信息的时候,finalize()将被自动调用,但是jvm不保证finalize()一定被调用,也就是说,finalize()的调用是不确定的,这也就是为什么sun公司并不提倡使用finalize()的原因。 总算把final、finally和finalize介绍完了，渴死了，先喝口水。大家现在应该不会被他们骗到了吧。其他它们是不会骗人的，只是被人利用了，是谁呀，还有谁，Java门神-面试官。]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA中常见的排序算法有哪些？---冒泡排序]]></title>
    <url>%2F2017%2F05%2F24%2F20170524%2F</url>
    <content type="text"><![CDATA[排序相关的的基本概念 排序： 将一组杂乱无章的数据按一定的规律顺次排列起来。数据表( data list): 它是待排序数据对象的有限集合。排序码(key):通常数据对象有多个属性域，即多个数据成员组成,其中有一个属性域可用来区分对象,作为排序依据。该域即为排序码。每个数据表用哪个属性域作为排序码，要视具体的应用需要而定。 我们常见的一些排序算法，如图所示： 交换排序交换排序的基本思想是：两两比较待排序记录（数据表）的关键字（排序码），发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。主要包括冒泡排序和快速排序。 现在，我们先一起来看看交换排序 之 冒泡排序 冒泡排序的原理 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 一听到冒泡这个词，大家可能会想到？对，没错，我们可以把冒泡排序看成生活中冒气泡的方式，从下往上冒，依次把最大或最小的值冒到最顶层。例如:有一个整型数组int[] nums = {84,83,88,87,61};其排序后的结果，如图：接下来，我们更进一步来分析它的比较过程： 冒泡排序的代码实现 i ： 控制第几轮，如果5个数，最多就比较4轮，所以i的索引从0开始的话，要循环4次，就应该是长度-1 j： 控制每一轮中的元素下标位置，每结束一轮，就会出来一个当前这轮中的最大值，则减i,之所以再减1，是因为最后剩一个元素的时候没有相邻的数与其分组，所以不用再比较了 12345678910for(int i = 0 ;i&lt;nums.length-1;i++)&#123; for(int j = 0;j&lt;nums.length-i-1)&#123; if( nums[j] &gt; nums[j+1])&#123; //相邻的两个元素比较 int temp;//借用第三个变量来达到两个元素的交换，如同交换两瓶水，需要第三个空瓶子 temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; &#125; &#125;&#125; 以上则是交换排序之冒泡排序的算法原理和具体实现步骤，敬请期待java中的其他排序算法]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[有GC就是爽，再也不用自己清理垃圾了]]></title>
    <url>%2F2017%2F05%2F21%2F20170521%2F</url>
    <content type="text"><![CDATA[Java中的“GC”是什么呢？它的英文是Garbage Collection，翻译过来就是垃圾回收，是JVM用来帮你回收Java程序中产生的垃圾的一种机制。对于Java工程师(码农)来说，了解垃圾回收机制（GC）有哪些好处呢？首先，可以装逼，哦，不不，可以满足Java工程师(码农)求知欲；其次，可以帮你写出更好的Java应用程序。 想了解GC，你得先了解它们：首先，来看JVM在运行时的内存图：这里呢，咱们只说说堆内存和栈内存堆内存：Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。你也可以这么理解，(敲黑板，往下划重点了)它是管理对象的，凡是new出来的对象，都在堆内存里。这块内存呢，是可以调配大小的，这里有参数：-Xms:设置JVM启动时最小的堆内存大小-Xmx:设置JVM堆的最大内存大小栈内存：(敲黑板，往下划重点了)一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。通过这个参数可以调配它的大小，-Xss：这个参数就是用来指定栈的大小这里咱们举个例子再来说明堆和栈，假如有这样两句话：int i=10;LovoStudent s = new LovoStudent();它们在JVM的内存中如何分配呢？看图：为何让大家看内存图呢？是为了说明什么是Java中的垃圾。那这个垃圾到底是什么呢？你可以这么理解，(敲黑板，往下划重点了)凡是不被引用变量引用的对象都是垃圾。哦豁，什么意思，自己去揣摩10分钟。揣摩完回来，咱们拿上面的例子来说，还是这句话，LovoStudent s = new LovoStudent(); 我把这个堆内存中的new LovoStudent();变成垃圾怎么来写？直接写 s=null;引用变量不再引用堆内存的对象，那这个对象就是垃圾。那么我问个智障问题，咱们所说的垃圾，会存在于JVM中哪块内存里？ 垃圾回收明白了以上的内容，垃圾回收原理就很容易理解了。垃圾回收机制就是JVM根据一定的算法和线程调度(这里只做简单认识，感兴趣的关注朗沃博客，后续有文章会详解哪些算法和线程调度)来处理产生的垃圾。这种机制对程序员来说，比10个G的高清无码岛国动作片都来的爽，因为你不用手动释放内存了，也不用担心内存泄漏问题。在其它语言中，比如C，手动释放内存很蛋疼呐！说到回收，不得不提Object类中的finalize()方法，当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。也就是说当一个对象被当作垃圾回收时，会调用该方法。既然如此，那咱们是不是可以写个类继承一下Object(废话，你能写个类不继承自Object么)，覆写finalize()，比如写个输出语句：System.out.println(“我成垃圾了，正在被回收”);来显式的看一看对象什么时候被回收的呢？完全可以。说完这个finalize()方法，还得说说System.gc()方法，这个方法又是干嘛的？运行垃圾回收器。调用 gc 方法意味着JVM做了一些努力(注意是一些努力，并不是100%，通常还是能回收的)来回收未用对象，以便能够快速地重用这些对象当前占用的内存。说完这些前提，咱们就可以设个场景，假如你去饭馆吃饭，首先得占个桌子，占了桌子之后呢就点菜上菜，假设你是土豪，可以点很多菜，陆续上来，先上的菜一来，你一顿的胡吃海塞留下很多垃圾，后来的菜再来，可能没地方放。开饭馆的肯定考虑这个问题啊，毕竟顾客是上帝嘛，于是安排了个服务员小妹儿，不定时的在场子里巡回，来收走你吃完菜的盘子。好像这问题就解决了，但是，不排除你是个吃货，吃的太快了，小妹儿来不及巡回到你这儿，你就有很多垃圾了，此时你是不是得大喊一声，“哎，小妹儿，到这儿收空盘子”，然后小妹儿对你微微一笑，“好的，我马上来收”(当然小妹儿也可能会说“哎呀，客官稍等，马上就来”)。至于在收盘子时候你们再发生点啥，那就得看自个了⋯⋯（嘿嘿嘿⋯⋯）好，打住，不是说好的讲GC的嘛，怎么扯到饭馆小妹儿了，咳咳⋯⋯是这样子，饭馆——JVM桌子——堆内存菜——对象空盘子等垃圾——未被引用的对象小妹儿不定时巡回收垃圾——JVM的一定算法和线程调度回收垃圾你喊小妹儿收盘子——调用System.gc()方法好了，只能解释到这儿了⋯⋯口说无凭，代码为证。写点代码验证一下：定义一个GCTest类代码如下：123456789101112131415161718192021222324252627282930public class GCTest &#123; private String name; public GCTest(String name)&#123; this.name= name; &#125; //覆写finalize()方法 @Override protected void finalize() throws Throwable &#123; // TODO Auto-generated method stub super.finalize(); System.out.println(this.name+"是垃圾，正在被回收"); &#125; public static void main(String[] args) &#123; //创建三个对象 GCTest gt1 = new GCTest("gt1"); GCTest gt2 = new GCTest("gt2"); GCTest gt3 = new GCTest("gt3"); //把对象去掉引用，变成垃圾 gt1=null; gt2=null; gt3=null; //调用gc()方法，主动回收垃圾 System.gc(); &#125;&#125;运行结果留给大家去测试了⋯⋯]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[向上转型，向下转型，还在头疼？]]></title>
    <url>%2F2017%2F05%2F18%2F20170518%2F</url>
    <content type="text"><![CDATA[在学习Java编程中，最头疼事情之一就是数据类型转换。有时候它在不经意之间就完成了（自动类型转换），有时候却又要求程序员必须手动指定（强制类型转换）。基本数据类型，转换规则还可以通过类型本身空间大小和精度分析明白，而且最多就是丢失精度但运行起来至少是不会报错。可是面对引用数据类型，这个“坑”就大了：有自动转的，有强制转的，居然还有强制都转不了的；自动转了的却把对象身上的方法丢了看不见；强制转的编译过了运行却可能报异常。 一口老血，有木有？更要命的是，这个转型还相当的重要，Java中的动态多态还非它不可了。你说要命不要命？没关系，今天就让我们花点时间聊聊它，搞定它！ 对象不是你想转，想转就能转先人说：知己知彼，百战不殆。我们先来认知一下引用数据类型的一些基本概念，以下所有分析都基于两个方面进行：Java语法 和 面向对象场景。在普通情况下，我们会书写这样的代码：1234Dog snoopy = new Dog();snoopy.play();//调用Dog的玩耍行为snoopy.sitDown();//调用Dog的坐下行为snoopy.shakeHands();//调用Dog的握手行为我们看到在这个语法当中，赋值符号左右两边的数据类型是相同。赋值号左边是Dog类的引用snoopy变量，指向了右边new出来的Dog类对象。这个语法在对应的日常场景中是非常形象的。我们用snoopy称呼一个狗对象，并且确定一定以及肯定snoopy就是一个狗东西。然后我们就可以大喊：snoopy来玩游戏啦，snoopy坐下，snoopy握手。你看，多自然。但是，如果我们写出下面的代码：12Dog snoopy = new Cat();snoopy.sitDown();赋值符号左右两边的数据类型是不同。赋值号左边是Dog类的引用snoopy变量，指向了右边new出来的Cat类对象。编译后，你就发现这句代码根本通不过。为什么？因为这个语法是荒谬的。snoopy明明是狗的代名词，结果你却让它指向了一只猫？还想让它执行狗才有的指令？铲屎的，你是不是不想活了？这个时候有同学想到了，那就强转。12Dog snoopy = （Dog）new Cat();snoopy.sitDown();这就更令人发指了吧，你要怎么做才能强行让一只猫咪对象变成一只汪对象？上帝也疯狂了……你觉得Java会让允许你干这种完全匪夷所思不合常理的事情吗？所以，这句代码的下场也只有一个，那就是编译不通过。因此，我们得到了第一个结论：在Java当中不是任意引用数据类型之间都能进行转换！那么，哪些引用类型之间可以呢？ 向上转型—自动转换，没问题我们分别定义两个类：一个叫做Pet（宠物）；一个叫做Dog，并且让Dog继承于Pet。12345public class Pet&#123; public void play()&#123; System.out.println("玩游戏"); &#125;&#125;12345public class Dog extends Pet&#123; public void sitDown()&#123; System.out.println("坐下"); &#125;&#125;那么，我们在需要调用处写下这个代码会发生什么呢？1Pet myBaby = new Dog();你会发现虽然在赋值符号两边的数据类型不一致，但是这句代码无论是编译还是运行都完全没有问题，也就是说Java中父类的引用指向子类对象是自动成功的。 这是为啥呢？其实无论是从语法上还是从场景分析上，我们会发现这是非常自然的，本身就应该自动成功。继承关系本就是一种is a关系，即所谓的“是一个“，所以Dog对象是一个Pet类型的呀（狗就是一种宠物嘛～～），这完全没有问题。在继承关系上，我们设计时通常在继承树上把父类画在上，子类在下，由于这种转型是沿着继承树往上走，所以我们把它称为–向上转型。但是，12myBaby.play();//编译通过myBaby.sitDown();//编译失败这又是为啥呢？因为myBaby是一个Pet类型的引用，所以是站在宠物的角度去看待汪对象。虽然对象还是狗狗，但是只能看到来自于父类宠物定义的play方法了。所以父类引用指向子类对象，只能调用到来自父类的属性／行为那如何调用到sitDown方法呢？答案很简单：换成狗的角度去看待这个汪星人。 向下转型—强制转换，有风险1234Pet myBaby = new Dog();myBaby.play();Dog snoopy = (Dog)myBaby;snoopy.sitDown(); 这段代码无论编译还是运行都不会有任何问题。我们先使用Pet类型的myBaby指向了狗对象，然后再换成Dog类型的snoopy去指向同一个狗对象。前者由于是父类型所以只能看到定义在父类的方法，后者是子类型，当然就可以看到狗对象身上的特有行为了。这种转型是从父类引用转为子类引用，从继承树的角度说就是向下转型。那为什么在把myBaby赋给snoopy的时候要使用强转语法呢？我们假设下面这种情况：如果Pet类还有一个子类叫做Cat类。12345public class Cat extends Pet&#123; public void climbTree()&#123; System.out.println("爬树"); &#125;&#125;然后书写代码：12345public class Master&#123; public void playWithPet(Pet myBaby)&#123; //操作代码 &#125;&#125;那么，你告诉我传进来的myBaby到底是Dog对象呢？还是Cat对象？或者是Pet对象？由于父类引用可以指向子类对象，所以上面几种情况皆有可能了。所以我们如果想转型Dog类，就必须强制告诉Java，myBaby确实是一个Dog类型的对象。因此我们需要在注释部分书写：1Dog snoopy = (Dog)myBaby;不过，就算你这么书写也只能保证编译通过，这个代码运行起来还是有可能失败，这就是所谓的强转风险性吧。如果你赋给myBaby的是🐶对象，当然没有问题；但假如赋的是🐱对象呢？这是不是相当于我们又从狗的角度去看待一个猫对象了？如何让一只狗变成一只猫，这又是一个荒谬的事情了。所以，如果向下转型想要编译和运行都成功，必须使用强制转型语法，还必须要求运行起来父类引用确实指向该子类的对象。所以，为了降低这种风险性，我们可以使用Java中的instance运算符，在强转前进行一次判断。所以最终代码是：123456789public class Master&#123; public void playWithPet(Pet myBaby)&#123; myBaby.play(); if(myBaby instanceof Dog)&#123; Dog snoopy = (Dog)myBaby; snoopy.sitDown(); &#125; &#125;&#125; 结论 在引用数据类型中，只有有继承关系的类型才能进行类型转换； 类型转换只是转换看待对象的引用的类型，对象本身没有也不可能参与转换； 父类引用可以自动指向子类对象，但只能访问和调用到来自于父类的属性和行为； . 子类的引用不能指向父类或其它子类对象，就算强转也会导致运行失败并抛出ClassCastException； . 把父类引用赋给子类引用，语法上必须使用强制类型转换，要想运行也成功还必须保证父类引用指向的对象一定是该子类对象（最好使用instance判断后，再强转）。]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[本博客书写教程：关于内容与风格]]></title>
    <url>%2F2017%2F05%2F08%2FcontentCourse%2F</url>
    <content type="text"><![CDATA[这篇文章是专门针对博客书写者进行内容选择与书写的一个简单说明。它主要涵盖了本博的目标人群、内容选取、书写风格这三个方面的要求。大家可以通过这些对自己的文章进行选题和渲染，既做到有的放矢又能够循循善诱寓教于乐，从而让本博发挥最有效的作用。 关于目标人群我们设定读取本博客的受众主要分为两种人群：1、LOVO教育Java方向的在读同学，在课后对学习内容回顾或扩展时可以通过阅读本博有所收获；能够在掌握学校教学内容的同时，又能够从更多角度看待这些知识点，还能够接触到更丰富的扩充内容；2、有志于自学Java的同学能够通过关注本博，从目前网络上浩如烟海的学习资源和市面上汗牛充栋的学习书籍中解脱出来；在这里能够获得清晰的学习结构，详细的学习内容和多维的学习方式，从而达到事半功倍的效果。 关于内容选取通过目标人群的设定，我们确定本博内容主要是依托朗沃的Java教材体系结构，针对Java课程的学习者（当然也包括愿意跟随朗沃体系结构进行自学的爱好者），提供教学内容的重点和难点进行讲解和扩展，并针对在面试中常见的一些题目进行解析回答。从内容分类上主要包括：计算机常识；Java基础编程；Java面向对象；数据库；客户端；JavaWeb；JavaEE框架；面向对象分析与设计；面试模拟问答等方面。 关于书写风格本博其实是朗沃教育在课堂之外的衍生，也是教学过程的一种辅助手段，所以在文章风格上还是以严谨但不失风趣为主，让阅读者能够在较为轻松的环境中有所收获。此外在手段上，除了文字和排版上要做到简练有趣，突出重点，如果还能配上合适的代码或图片更佳。总之，本博希望成为一个能够吸引各位读者的学习平台，让大家能够更有收获。]]></content>
      <categories>
        <category>本博教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[本博客书写教程：关于书写格式]]></title>
    <url>%2F2017%2F05%2F07%2FwriteCourse%2F</url>
    <content type="text"><![CDATA[本博客是发布在github上的，而github上提供挂载的是静态网站和静态资源，是一种低成本的公共展示手段。我们利用hexo这个工具把本地的MarkDown文件自动生成为静态页面，然后再上传到github上。所以，各位老师要为本博客提供的原文件必须是一篇能被hexo正确解析的MarkDown文件。接下来，我们就来介绍一下这种格式。 文件开头在文件的开头部分，请按照下图的方式进行书写：1、首先用三根短横线开头，再用三根短横线结束；2、中间内容分别是标题（title）、日期（date）和分类（categories）；3、注意冒号后面一定要有一个空格。 文件内容在完成文件开头后，你可以在下一行开始书写内容了。在书写内容时，请先在第一段用简短的文字书写一个内容概要，然后换行使用more标记进行分割。这样，这篇文章在首页就只会显示第一段内容，只有点击《阅读全文》才能看到后面的内容了。书写方式和效果如下：文章内容在书写过程中，只需要在每段的结束时换行，不需要（也不能）在每段开始的时候使用TAB或空格进行缩进。其余效果语法请参见MarkDown语法即可。 如何插入图片在文中插入图片是我们书写时的重要的说明手段，在HEXO中有两种语法可以插入图片，这里我们推荐使用:图片路径可以由上传者调整，但是需要各位作者老师把图片一同交与上传者。请注意：图片最好使用jpg或png格式；另外为节约空间，图片大小最好保持在几百k就够了；图片的名称请按照在文章中出现的顺序数字进行命名。 如何插入代码技术文章当然少不了代码的出现，HEXO中采用的支持语法是：用codelock和endcodelock把你的代码括起来，其中lang属性后面跟上代码的所属语言即可。HEXO可以自动找出该语言的关键字、变量、注释等进行变颜色操作。效果如下：1234567try &#123;... //需要异常处理的代码&#125; catch（） &#123;...//捕获到异常后执行的代码&#125; finally &#123;…//有没有捕获到异常都要执行的代码&#125;]]></content>
      <categories>
        <category>本博教程</category>
      </categories>
  </entry>
</search>