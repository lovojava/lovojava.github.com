<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA中常见的排序算法有哪些？---选择排序]]></title>
    <url>%2F2017%2F07%2F16%2F20170716%2F</url>
    <content type="text"><![CDATA[排序相关的的基本概念 排序： 将一组杂乱无章的数据按一定的规律顺次排列起来。数据表( data list): 它是待排序数据对象的有限集合。排序码(key):通常数据对象有多个属性域，即多个数据成员组成,其中有一个属性域可用来区分对象,作为排序依据。该域即为排序码。每个数据表用哪个属性域作为排序码，要视具体的应用需要而定。 我们常见的一些排序算法，如图所示： Java中的经典算法之选择排序（SelectionSort）原理：每一趟从待排序的记录中选出最小或最大的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在n-i+1(i=1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。 现在，我们先一起来看看什么是排序?简单选择排序的基本思想：给定数组：int[] arr={里面n个数据}；第1趟排序，在待排序数据arr[0]~arr[n-1]中选出最小的数据，将它与arrr[0]交换；第2趟，在待排序数据arr[1]~arr[n-1]中选出最小的数据，将它与r[1]交换；以此类推，第i趟在待排序数据arr[i]~arr[n]中选出最小的数据，将它与r[i]交换，直到全部排序完成。 简单来说：比如在5个数据中，如果要做升序排序，我们分别要在这5个数中找出最小值放在第一个位置，第二小值放在第二个位置，依次类推，最后那个肯定就是第5小值 例如:有一个整型数组int[] nums = {84,83,88,87,61}; 其排序后的结果，如图：接下来，我们更进一步来分析它的比较过程： 选择排序的代码实现i:控制总轮数j:控制元素的索引位置分析：5个元素，需要4轮比较，也就是说n个元素，需要n-1轮比较,看上面的情况执行情况，第几轮，j就从第几个元素开始依次和后面的元素比较,则从j=i开始 1234567891011int[] nums = &#123;84,83,88,87,61&#125;;for(int i = 0;i&lt; nums.length-1;i++)&#123; for(int j=i;j&lt; nums.length-1;j++)&#123; if(nums[i] &gt; nums[j+1])&#123; int temp ; temp = nums[i]; nums[i] = nums[j+1]; nums[j+1] = temp; &#125; &#125;&#125; 以上则是选择排序的算法原理和具体实现步骤，敬请期待java中的其他排序算法]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[enum，你应该知道的枚举]]></title>
    <url>%2F2017%2F07%2F13%2F20170713%2F</url>
    <content type="text"><![CDATA[很多同学在学习Java的过程中可能会听到一种叫枚举的数据类型，那到底什么是枚举呢？ 在Java程序中又是怎么使用枚举的呢？ 下面我们就简单的讲解下这个神秘的枚举类型。 什么是枚举？枚举：枚举其实就是一种数据类型，跟int, char 这种差不多。是JDK1.5以后引入的一种新的数据类型。 它有一定的特点就是：在创建好一个枚举类型后，能够使用的量，只能是enum里面规定的值。 当然在定义枚举时，有要求：枚举中的量必须是不变的，并且是有限的。 什么意思呢？ 例如： 一周中的周一(MONDAY), 周二(TUESDAY), 周三(WEDNESDAY), 周四(THURSDAY), 周五(FRIDAY), 周六(SATURDAY), 周末(SUNDAY)。 对于我们来说，一周中的时间，从周一到周末是不会改变的，并且是有限的，就可以使用枚举来展示一周中的数据。 当然除了一周的时间的满足条件以外，在生活中还有很多枚举的存在，如：“春夏秋冬”四季、“上下左右”方向，也可以使用枚举来表示。 那我们在Java程序中如何书写枚举呢？当然同学们都是有一定Java基础的，那如果我们想要把一周的时间表示出来，在JDK1.5之前，那时没有枚举的话，该怎么做呢？ 通过初步分析，我们发现一周中的时间都是不变的，那我们应该使用常量来表示 代码如下： 123456789public class Week&#123; public static final String MON = "MONDAY"; public static final String TUE = "TUESDAY"; public static final String WED = "WEDNESDAY"; public static final String THU = "THURSDAY"; public static final String FRI = "FRIDAY"; public static final String SAT = "SATURDAY"; public static final String SUN = "SUNDAY";&#125; 这样定义后，在Java代码中可以直接使用Week.MON的方式来调用Week类中的值。 当然，我们还可以偷个懒，将上述代码写在接口中(因为接口定义的变量默认都是public static final) 最终变成： 123456789public interface IWeekConstants &#123; String MON = "Mon"; String TUE = "Tue"; String WED = "Wed"; String THU = "Thu"; String FRI = "Fri"; String SAT = "Sat"; String SUN = "Sun";&#125; 这样确实要简单一点了，那我们用枚举还能更简单吗？ OK，我们用枚举试试： 123public enum WeekEnum &#123; MON, TUE, WED, THU, FRI, SAT, SUN;&#125; 这真不是一般的简单。 在我们使用枚举时只需要把确定的值一个一个的列举出来即可，因为在使用枚举来表示这些数据时它们就已经确定了值，并不需要担心量的变化。 所以，在某种情况下，使用枚举也是一种不错的选择。 当然，在定义枚举的过程有有一些要求： 1.首先创建枚举类型要使用 enum 关键字–public enum WeekEnum{}，类似于类的创建过程。 2.每个枚举量之间用“,”隔开，就像：MON, TUE, WED, THU, FRI, SAT, SUN 当然，最后的SUN后面可以不加“;”，但为了代码整体的展示，加上“;”更能体现书写代码时的好习惯。 OK，到这里，肯定会有人会问：“枚举怎么写得那么简单啊！” 其实枚举仅仅只是看起来写得很简单。 枚举书写简单的原因是：在枚举中，每一个枚举对象在创建时都会默认继承java.lang.Enum这个类。 但由于java.lang.Enum这个类是抽象类，所以不能直接创建其对象。 所以每写一个枚举对象，实际上就创建一个Enum的子类（Enum本身是一个抽象类），而在每次创建枚举的子类时都会自动映射到下述的构造器中创建对象： 1protected Enum(String name, int ordinal) 在该构造器中，每个枚举的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。 例如上述的枚举代码中，一共是周一到周末，创建了7个枚举对象，相当于调用了7次 1protected Enum(String name, int ordinal) 在这个构造函数中，name 是常量，如：上面所写的MON,TUE等；ordinal是被创建序数（从0开始）。 效果相当于： 123456public enum WeekEnum &#123; new Enum&lt;EnumTest&gt;("MON",0); new Enum&lt;EnumTest&gt;("TUE",1); new Enum&lt;EnumTest&gt;("WED",2); ...&#125; 所以说，枚举看起来很简单，但是在执行时依然做了很多准备工作。 那在Java代码中怎么运用呢？用法一：常量123enum Color&#123; GREEN, YELLOW, RED&#125; 上述例子中，GREEN, YELLOW, RED都是常量，这是枚举中常用的方式之一。 我们首先创建了一个枚举类，并且在其中创建3个枚举对象 接下来看看如何得到枚举中的子类对象 12345public class TrafficLight &#123; //使用枚举对象和使用静态属性差不多 //首先通过枚举名，再加上.运算符找到对应的常量名，返回的是一个枚举对象 Color color = Color.RED; //那么color就是一个枚举对象，并对应RED 通过上述例子，相信同学们都大致了解如何获得枚举对象了。 上面我们也说了枚举和int、char一样都是数据类型，那能不能在switch中使用呢？ 用法二：switch接下来看看在switch中如何使用枚举 接着上面的代码： 12345678910111213public void change() &#123; switch (color) &#123;//将枚举对象放入switch参数列表中 case RED: System.out.println("红色"); break; case YELLOW: System.out.println("黄色"); break; case GREEN: System.out.println("绿色"); break; &#125;&#125; 将枚举对象放入switch参数列表中是JDK1.5以后的新方式，可以把枚举对象看做参数来使用，其对应的就是它所代表的的值。 如上述代码中，Color color = Color.RED;先取出枚举对象，然后赋值给color。 这时color枚举对象对应的就是RED，所以，在case选择过程中，会被case RED选中，进而执行case RED中的语句，最终输出“红色”。 同理如果在创建枚举对象时使用的是Color.YELLOW，则枚举对象对应的就是YELLOW，则会执行对象case YELLOW中的语句输出“黄色”。 注意：在前面也说了，只能使用枚举中已经写好的对象，所以使用其它没有的枚举对象是会出现错误的。 从上述代码中相信大家已经基本了解了如何在代码中来使用我们的枚举对象了，同时，也了解了switch中枚举的新用法。 下面来个有难度的。 之前我们说过，枚举类型在创建时很类似类的创建，那枚举能不能和类一样，在枚举中创建方法呢？ 用法三：向枚举中添加新方法如果打算自定义自己的方法，那么必须在enum实例序列的最后添加一个分号。而且 Java 要求必须先定义 enum 实例。 怎么书写呢？ 12345678910111213141516171819202122232425262728293031323334public enum Color &#123; //先定义 enum 实例 RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4);//；不能忘掉 // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; // 普通方法 public static String getName(int index) &#123; for (Color c : Color.values()) &#123; if (c.getIndex() == index) &#123; return c.name; &#125; &#125; return null; &#125; // get set 方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125;&#125; 从上述代码中，我们发现其中不仅创建了枚举的对象，同时还出现了构造器、成员变量和对应的get、set方法，并且还加上了一个普通的方法。 尤其是RED(“红色”, 1)这种形式的数据。其相当于在创建枚举的RED、GREEN等对象时，使用构造器把构造出来的对象与枚举对象进行了绑定。 相当于枚举类中的对象只有RED、GREEN、BLANK、YELLO，而这些对象分别拥有对应的两个成员变量：name和index。 当然这种定义方式我们很少见，不过一定得知道哦，不然被问到就尴尬了。 那上述的代码，我们能不能还像刚才那样对枚举对象进行使用呢？ 通过代码给大家展示一些常用的方法： 123456789101112131415161718192021public static void main(String[] args) &#123; //使用Color.values(),可以返回一个Color类型的数组 Color c[] = Color.values(); //既然是个数组，进行遍历 for (Color color : c) &#123; //使用get、set方法中的get方法，得到c对象中对应的name值。 System.out.println(color.getName()); //使用get、set方法中的get方法，得到c对象中对应的index值。 System.out.println(color.getIndex()); //使用枚举类的方法ordinal()，得到枚举对象的索引值（从0开始） System.out.println(color.ordinal()); //使用枚举类的方法name()，得到枚举对象的名称 System.out.println(color.name()); //直接输出枚举对象 System.out.println(color); &#125; //根据枚举的静态方法，通过字符串找到对应的枚举对象 //如果该对象不存在，则出现java.lang.IllegalArgumentException异常 Color c1 = Color.valueOf("RED"); System.out.println(c1);&#125; 下面对上述方法进行了简单的归纳 简单介绍在枚举中常用的一些方法： 1.使用Color.values(),可以返回一个Color枚举类型中枚举对象的数组。Color[] c = Color.values(); 2.也可以通过枚举类中定义的方法： 首先获得枚举类的对象Color c = Color.RED; 通过枚举类中的方法：c.getName()（这个是get、set方法），得到c对象中对应的”红色”值。 当然也可以通过getIndex()（这个是get、set方法）得到写出的数值。 3.可以使用枚举类的枚举对象子代的方法： 同样首先获得枚举类的对象Color c = Color.RED; （1）c.ordinal();得到该枚举对象的索引值，当然，索引是从0开始。 （2）c.name();得到对应的对象名称如：RED。 （3）System.out.println(c)，直接输出枚举对象,获得的同样是对象名称：RED。 （4）静态方法使用枚举类来调用如：Color.valueOf(“RED”)，根据传入的字符串，找到对应的枚举对象。 通过上述内容，相信大家对枚举也有了一定的了解。 既然在枚举中我们可以自定义方法，那能不能像类一样去重写父类中的方法呢？ 用法四：覆盖枚举的方法下面给大家展示一个比较简单的重写例子： 我们在枚举中重写toString()方法（所有类的都会隐式的继承Object类）： 12345678910111213141516public enum Color1 &#123; RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4); // 成员变量 private String name; private int index; // 构造方法 private Color1(String name, int index) &#123; this.name = name; this.index = index; &#125; //覆盖方法 @Override public String toString() &#123; return this.index+"_"+this.name; &#125;&#125; 重写了toString()方法后，发现在输出枚举对象时，其输出内容也发生了改变，当然，在枚举中也可以加上main方法直接使用 例如： 1234567891011121314151617181920public enum Color1 &#123; RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4); // 成员变量 private String name; private int index; // 构造方法 private Color1(String name, int index) &#123; this.name = name; this.index = index; &#125; //覆盖方法 @Override public String toString() &#123; return this.index+"_"+this.name; &#125; public static void main(String[] args) &#123; Color1 c = Color1.BLANK; System.out.println(c); &#125;&#125; 输出的结果也不再是BLANK,而是“3_白色”。 通过上面的讲解，我们发现，虽然枚举在创建过程中和类不同，但是枚举和类是非常相似的。 下面再给同学们列举一些枚举的其它用法。 用法五：实现接口这里简单的给大家介绍下枚举如何实现接口。 直接上代码： 首先是接口： 1234public interface Behaviour &#123; public void print(); public String getInfo();&#125; 枚举代码： 123456789101112131415161718192021public enum Color implements Behaviour&#123; RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; //接口方法 @Override public String getInfo() &#123; return this.name; &#125; //接口方法 @Override public void print() &#123; System.out.println(this.index+":"+this.name); &#125;&#125; 和我们类实现接口是一样的，必须要求实现接口中的方法，并且还有一点特殊点就是枚举不能只实现接口的方法，还必要书写枚举中的量才可以。 也就是说，必须有RED(“红色”, 1), GREEN(“绿色”, 2), BLANK(“白色”, 3), YELLO(“黄色”, 4);这些枚举的量，否则就会报错误。 提一个小问让同学们想一想：枚举可以实现接口，那枚举可以继承类吗？ 这个答案一定是：不可以！（枚举默认java.lang.Enum这个类，而Java只能单继承，所以不可以！） 用法六：使用接口组织枚举什么是使用接口组织枚举呢？ 简单的说就是在接口中创建多个枚举变量，其中枚举同时实现该接口 比如说： 12345678public interface Food &#123; enum Coffee implements Food&#123; BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO &#125; enum Dessert implements Food&#123; FRUIT, CAKE, GELATO &#125;&#125; Food接口的作用就是将其所包含的enum（Coffee、Dessert）组合成一个公共类型，可以使用Food对其中的枚举进行管理 那这样我们如何使用枚举中的值呢？ 可以使用： 1.Coffee coffee = Food.Coffee.BLACK_COFFEE; 2.Coffee coffee = Coffee.BLACK_COFFEE; 3.Food coffee = Coffee.BLACK_COFFEE; 来创建出枚举的对象，其它的方法没有区别，当然还可以在接口中添加一些抽象方法 比如： 1234567891011121314151617public interface Food &#123; enum Coffee implements Food &#123; BLACK_COFFEE, DECAF_COFFEE, LATTE, CAPPUCCINO; @Override public void use() &#123; System.out.println(Coffee.this.getClass()); &#125; &#125; enum Dessert implements Food &#123; FRUIT, CAKE, GELATO; @Override public void use() &#123; System.out.println(Dessert.this.getClass()); &#125; &#125; public void use();&#125; 用法七：关于枚举集合的使用在Java中有java.util.EnumSet和java.util.EnumMap是两个枚举集合。 EnumSet保证集合中的元素不重复。 EnumMap中的 key是enum类型，而value则可以是任意类型。 简单的给展示下两种枚举集合 EnumSet代码： 123456789101112131415161718192021222324252627enum Color &#123; RED, GREEN, BLUE;&#125;public class EnumSetDemo &#123; public static void main(String args[]) &#123; // 声明一个EnumSet对象 EnumSet&lt;Color&gt; esOld = null; EnumSet&lt;Color&gt; esNew = null; // 将枚举的全部类型设置到EnumSet对象之中 esOld = EnumSet.noneOf(Color.class); // 增加内容 esOld.add(Color.RED); // 增加内容 esOld.add(Color.GREEN); // 从已有的集合拷贝过来 esNew = EnumSet.copyOf(esOld); print(esNew); &#125; // 专门的输出操作 public static void print(EnumSet&lt;Color&gt; temp) &#123; // 循环输出EnumSet中的内容 for (Color c : temp) &#123; System.out.print(c + "、"); &#125; System.out.println(); &#125;&#125; EnumMap代码： 12345678910111213141516171819202122232425enum Color &#123; RED, GREEN, BLUE;&#125;public class EnumMapDemo &#123; public static void main(String args[]) &#123; // 定义Map对象，同时指定类型 Map&lt;Color, String&gt; desc = null; // 实例化EnumMap对象 desc = new EnumMap&lt;Color, String&gt;(Color.class); // 添加数据 desc.put(Color.RED, "红色"); desc.put(Color.GREEN, "绿色"); desc.put(Color.BLUE, "蓝色"); // 遍历，并进行输出 for (Color c : Color.values()) &#123; System.out.println(c.name() + " --&gt; " + desc.get(c)); &#125; for (Color c : desc.keySet()) &#123; System.out.print(c.name() + "、"); &#125; for (String s : desc.values()) &#123; System.out.print(s + "、"); &#125; &#125;&#125; 根据上述举的例子，希望同学们对于枚举集合的使用有个直观的感受。 说了这么多，希望大家对枚举有更深入的了解，其实枚举只是一个Java和其它很多语言中的一种数据类型而已，只是由于其特殊的写法，在程序中运用有所不同。 总结这里简单的总结一下： 1.由于枚举的出现时间比较晚，在我们的项目中使用的频率是比较低的，但是懂得枚举的使用可以使你的代码更为简洁明了。 2.虽然枚举的使用看起来很简单，但它也有自身的局限性（要求枚举中的数据全是不变的，有限的），所以，在编写程序的过程中应该灵活运用所学的只是，这样才能使自己的程序写得越来越好。 好的代码不是一蹴而就的，需要反复琢磨与思考，懂得合理运用才能事半功倍。]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[泛型，你也可以自定义]]></title>
    <url>%2F2017%2F07%2F10%2F20170710%2F</url>
    <content type="text"><![CDATA[一提到泛型，大家首先想到的就是。在集合中加入泛型，来规定集合中元素的类型。那么，什么是泛型？为什么要使用泛型？泛型除了集合以外，还可以在其他地方使用吗？我们今天就来了解一下。 1、为什么要使用泛型？首先，我们来看一下ArrayList集合类的定义： 1234public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;&#123; private transient Object[] elementData; ……&#125; 可以看到，ArrayList底层是使用数组实现的。而且，该数组是Object数组。这就意味着，在该数组中，我们可以存放任何类型的元素 1234List list = new ArrayList();list.add("123");list.add(new Integer(200));list.add(new JFrame()); 元素存放进集合后，我们遍历数组 12345for (int i = 0; i &lt; list.size(); i++) &#123; Object obj = list.get(i);//1 String str = (String)obj;//2 System.out.println(name);//3&#125; 运行代码，在2处，会抛出java.lang.ClassCastException。这是类型转换异常。 原因是，在1处，我们先取出集合元素，创建了Object变量obj。按照多态的概念，父类变量可以指向任何一个子类对象。而Object是所有类的父类，所以变量obj可以指向任何一个子类对象。所以，1处的代码实际是： 123Object obj = "123";Object obj = new Integer(200);Object obj = new JFrame(); 很明显，在2处，将obj类型强转为String类型时，对于第一个元素是可以的。第一个元素指向的是字符串对象。但第二个元素是Integer对象，第三个元素是JFrame对象。将这样两个对象强转为String类型，当然会转换失败。 在以上代码中，存在的问题在于，ArrayList集合元素定义的是Object数组。该数组中可以存放任何类型的对象。所以，我们并不清楚集合元素，到底指向的是什么样的对象。所以，在使用集合元素时，会先进行类型转换，再调用方法。这时，如果不清楚集合中存放元素的类型，那么，就很容易抛出java.lang.ClassCastException类型转换异常。 那么能不能规定，集合中只能存放什么类型的元素，从而在使用集合元素时，开发者可以清晰的知道集合元素的类型，因此避免这样的类型转换异常呢？泛型，可以解决这些问题。 2、什么是泛型？泛型，大家可以理解为“参数化类型”。也就是，可以将一个类中的某些属性的数据类型、方法参数类型、返回类型，都以变量方式表示。在使用/调用时传入具体的类型。 我们来看一下，集合中是如何规定集合元素类型的。 123456public class ArrayList&lt;E&gt;&#123; …… public E get(int index) &#123;……&#125; public boolean add(E e) &#123;……&#125; ……&#125; 注意这个E。这可以看做是参数化的类型，ArrayList中采用泛型化定义之后，中的E表示类型形参，可以接收具体的类型实参，凡是出现E的地方，均表示相同的接受自外部的类型实参。换句话说，在定义ArrayList对象时，规定是什么类型，那么凡是引用类型变量E的地方，就是什么类型。 例如： 12345678//定义了E参数的类型为StringArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素时，add方法参数为E变量类型。由于定义list对象时，定义了类型为String，那么add方法形参变量类型就是String类型list.add("abc");//编译错误，定义list对象时，泛型为String，只能添加String对象list.add(new JFrame());//get方法返回的是E变量类型。由于定义list对象时，定义了类型为String，那么get方法返回的就是String类型String str = list.get(0); 集合中解决类型转换异常的思路是：通过对象中泛型的定义，在添加元素时，规定只能添加某个类型的元素。如果添加其他类型的对象，那么编译错误。这样，取集合元素时，当然也只能取出同一类型的对象。这样就避免了类型转换异常。 所以，从在加上泛型定义的集合中取出元素时，无需进行类型转换，直接可以定义泛型变量接收集合元素。同样的两个ArrayList集合，也可以通过不同泛型的定义，从而规定存放集合的元素类型。 12ArrayList&lt;String&gt; slist = new ArrayList&lt;String&gt;(); //只能存放String对象 ArrayList&lt;Integer&gt; ilist = new ArrayList&lt;Integer&gt;();//只能存放Integer对象 我们也可以给一个类或一个接口，定义多个泛型参数。 例如，Map集合定义如下： 1234public interface Map&lt;K,V&gt; &#123; V put(K key, V value); V get(Object key);&#125; 定义Map对象时，我们可以给其中的键对象K，和值对象V，指明具体的类型。那么，凡是引用K类型的属性类型、方法参数，方法返回类型，就必须和定义Map对象时的K类型一致。同样，凡是引用V类型的属性类型、方法参数、方法返回类型，也必须和定义Map对象时的V类型一致。 123456789//键定义为Integer类型，值定义为Student类型Map&lt;Integer,Student&gt; map = new HashMap&lt;Integer,Student);//通过，1在添加元素时，会自动包装成Integer。键和值类型和定义map的类型匹配map.put(1,new Student());//编译错误，添加元素键对象的类型，和map对象中定义的键类型不匹配map.put("1",new Student());//返回类型和V值类型一致Student s = map.get(1); 3、自定义泛型那么，泛型的定义是否只限于集合框架呢？当然不是，凡是需要定义类型参数的类、接口、方法都可以使用泛型。 例如：集合框架中有一个工具类：Collections。该类中提供了一个sort排序方法，定义如下： 123public class Collections&#123; public static void sort(List&lt;T&gt; list, Comparator&lt;T&gt; c)&#123;……&#125;&#125; sort方法在给集合元素排序时，需要由开发者定义排序的规则。这样，要由开发者实现Comparator接口，从而定义集合元素的比较规则。 不过，开发者在实现Comparator接口时，需要指出，是给什么样类型元素定义比较规则。 Comparator接口定义如下： 123public interface Comparator&lt;T&gt; &#123; public int compare(T o1, T o2);&#125; 开发者在实现接口时，定义了Comparator比较器泛型类型后，compare方法参数的类型，就变成了定义比较器泛型的类型。 1234567new Comparator&lt;Student&gt;()&#123; public int compare(Student o1, Student o2) &#123; return 0; &#125; &#125;; 开发者在重写compare()方法时，就可以定义两个Student对象比较的规则了。 从以上内容，大家已经明白了泛型的具体运作过程。也知道了接口、类和方法也都可以使用泛型去定义。在具体使用时，可以分为泛型接口、泛型类和泛型方法。 在实际开发中，我们也可以通过泛型的定义，来规范一些属性、方法参数，以及返回类型。 例如，我们在做分页时，可以将页面显示的数据、总记录数和总页数，封装成专门用于分页的实体类。 12345public class CutPageBean&#123; private List list = new ArrayList(); private int count; private int totalPage;&#125; 在需要分页的方法中，以CutPageBean做为返回类型。不过，在设计时，为了让开发者更清楚的知道，list属性中存放元素的类型，我们可以定义泛型去规范。 12345public class CutPageBean&lt;T&gt;&#123; private List&lt;T&gt; list = new ArrayList&lt;T&gt;();; private int count; private int totalPage;&#125; 这就意味着，创建CutPageBean时，规定了泛型类型后，list属性中存放元素的类型，就和定义CutPageBean对象时的类型一致。 12CutPageBean&lt;Student&gt; cutBean = new CutPagBean&lt;Student&gt;();cutBean.getList().add(new Student()); //在list集合属性中只能存放Student类型。 这样，在设计业务接口方法，以及实现时，可以明确的知道应该将什么样的对象，存放进分页实体对象定义的集合属性中。 总结：1、泛型，表示参数化类型。可以将一个类中的某些属性的数据类型、方法参数类型、返回类型，都以变量方式表示。在使用/调用时传入具体的类型。2、可以给一个类或一个接口，定义一个或多个泛型参数。使用的类型和泛型定义的类型一致。3、泛型，我们也可以根据业务需要进行自定义。接口、类和方法也都可以使用泛型去定义。]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[（转）当编程语言变成二次元萌妹]]></title>
    <url>%2F2017%2F07%2F07%2F20170707%2F</url>
    <content type="text"><![CDATA[试想一下，当Java、C++、Python、Ruby、PHP、C#、JS等编程语言变成了动漫人物会是怎样的一幅场景呢？下面就一起看看在日本作家渡辺将人的笔下，各种编程语言都是哪类“美女”的吧！ Java 犹如宫泽贤治的《不畏风雨》中出现的、性格木讷的女孩子。从小就由于迟钝和大食量等特征被别人当作笨蛋，从小学入学开始进入田径部、坚持跑步，在中长跑中经常取得好成绩，给人以活泼的印象。是十分努力的女孩子。她的家境并不算好。父亲Sun是有才能的艺术家，但不擅长理财，在她14岁的时候因为苦于借债积劳成疾而去世。她被Oracle叔叔收养，那时还与Google叔叔之间因为对她的扶养权问题而引起争端并闹上法庭。在周围的人都担心，正值青春期时她在这样的处境下会不会一蹶不振的时候，她却处变不惊、继续着每天练习跑步的生活。朴素的、认真的、难说是聪明的她，进入高中后不知是不是稍稍开始对异情在意，被人看到她偷偷地学着别的女孩子的时尚穿着在街上行走。虽然会受到“虽然很努力，也许稍微有点过时”、“那衣服与Java的印象不合”之类的否定评价，但感到“意外地很萌？”的好意的人也很多。喜欢喝咖啡，只喝印度尼西亚产的。其本人曾说过“喜欢咖啡胜过三顿饭”，不禁让人稍稍担心“这样对健康没问题吗？” C++ 苗条的双腿和协调的五官。被许多人称作“IT界首屈一指的美女”的她，也因为拥有插花、茶道、钢琴和小提琴、柔道、剑道、合气道等等才能而出名。她的粉丝大多很狂热，还存在着“黑暗军团”这样的粉丝俱乐部。黑暗军团的是规模仅次于共济会（Freemason）的巨型团体，一般人无法入会。据说如果能回答出对她非常狂热的问题，就会有察觉到的军团成员来询问“你愿意进入黑暗军团吗？”与她同父异母的姐妹Objective-C一心专注于弹钢琴，她的专注被IT界的天才史蒂夫乔布斯（也被一部分人称为紫色蔷薇）相中，而一跃成为明星，而C++则是由于其美貌和才能被人关注，长年坐稳业界明星的宝座。姐妹二人真可谓是对比鲜明。她根据心情不同频繁地变换发型和服装这一点也很出名。昨天还是和服配黑发，今天却是红发哥特系登场之类的，因为她的变身而使轻度的粉丝惊奇道“啊嘞？今天是C++小姐吗？”的事也常有发生。远离业界时私下经常穿HYSTERIC GLAMOUR的服装。关于她的出身年月日其事务所并不公开。虽然也有出身于1983年一说，本文采用的是在一部分粉丝中流传甚广的1985年10月14日说。其间也流传有“她自己也许也记不清自己的生日……”这样煞有介事的传言。与其说“C++小姐的话记不清自己的生日也不是什么不可思议的事情”，倒不如看作是她天真烂漫的性格的表现。 Python 由Guido父上养大的深闺中的大小姐。她出身于荷兰的阿姆斯特丹，但在小时候就搬到了美国，父亲也在家里使用英语，所以不怎么会说荷兰语。她个性随和。最出名的是她听C++宣布“想出去旅行一趟改变一下形象。200x年回来哦”出门旅行后（结果回来的时候已经2011年了……），放言说“我也稍稍出门旅行一下，公元3000年再回来哦”后出门数年未归。虽然有着这样冒失的行动，但多亏抱着“养成大家都喜爱的孩子”的心愿的Guido父上大人的教育，实际上和她接触后会觉得她非常容易亲近。前些天，她来到作者的朋友的公司打工（她现在似乎在边上大学边打工），被人们评价为“能充分融入工作、八面玲珑、给我们帮了大忙”。她不怎么说多余的话，彬彬有礼的样子，被评价为是在“天真烂漫、自由第一”的人众多的业界中与众不同的存在。据说她擅长的科目是数学，经常看到她轻松地解决各种统计相关的难题。喜欢穿白色的连衣裙或浅粉色的开衫这样清新的服装。实际上她还喜欢爬行动物，据说在家里还有养蛇。粉丝们经常讨论“她会给宠物们起什么样的名字呢？”这样的话题。大多得出的都是“肯定是Monty吧”这样的结论。会不会飞就不得而知了。 Ruby 由松本爸爸养大的日本的女孩子。因为生日在圣诞节，人生最大的烦恼是生日礼物和圣诞节礼物变成一份了。出生地是岛根县松江市，除了旅游和工作以外没有到过其它的县。由于受的教育是自由奔放式的，她性格好动、好奇心旺盛。平时是一个率真的好孩子，但偶尔也会看到她喜欢恶作剧的一面，这让周围的人十分困扰。看到她的身影时经常会想起IT业的“Just For Fun !”这句话。小时候过着一个人在荒山野岭到处跑的生活，10岁的时候与一个叫Rails的女孩成为朋友，生活开始变化。两个人玩耍时停在了演艺事务所门前，谈起可以两个人结对进行演艺活动。以“Ruby与Rails”的艺名出道、主要从事杂志模特，也有拍过电视广告，所以很多人都听过她们名字。人们想着她在这多愁善感的年龄段体验各种演艺活动、性格多少会产生一些变化吧，但在前些天与她久违的谈话中，却惊讶地发现她仍是与从事演艺活动之前一样行动自由奔放。虽然行为举止多多少少显得更加稳重，其喜欢恶作剧、活泼的本性却和以前一样没有变化。想着已经是高中生了差不多也要开始穿一些成熟一点的服装的她，对于洋装却和小时候一样穿着Mickey Mouse。虽然她个子小又是娃娃脸与这样的衣服很配，不过这样真像一个女高中生吗？她的粉丝也分为想要她一直保持现在的样子，和想要看到她更成熟的样子的两派。 PHP 以强化Web世界为目的制作出来的女性机器人。竖着的头发是用作天线来随时接收主人的命令的。为了有与人类相近的触感，使用了硅树脂来制作其皮肤。内部是类似于刀片服务器的构造，常常使用多台服务器进行复用。因此体重比人类更重一些。在她最初登场的时候，还能看到她关节可动部分的骨架，行动也很僵硬，与人类的形象差别很大。然而经过了18年间6次的大版本升级之后，其行为和言语已经渐渐变得像人了。最近更是达到了像初音未来这样（比起人类仍然有少许违和感但已经十分自然了）的级别。虽然笨笨的、工作时也磕磕绊绊的，但由于她遵循机器人三原则、服从主人的命令，也有很多人成为她的粉丝。她的粉丝俱乐部官网“PHPer！”无需入会费便可简单入会，是会员数在IT界首屈一指的大团体。对于她持拒绝态度的人也很多，常有“她的行为在生理上有些难以接受”、“如果再聪明点就好了”、“与她稍有过接触但觉得还是与人类差别很大”这样的评论。平常穿从Forever12和志村买来的衣服。想着穿便宜的快速时尚（fast fashion）衣服便可以将省下的钱花在机器开销上。可以说是标准的机器人的效率优先的花钱方式。或许会有她也在意流行、为样子烦恼的那一天吧？ C# 在著名的微软公司接受精英教育、11岁时便跳级进入大学学习、倍受人们关注的少女。也被称为“IT界的最强幼女”。因为与C++的名字很像，一段时间内盛传“难道是私生子吗？”的流言，实际上两人没有直接的血缘关系。也有报道称两人是远房亲戚，但实际情况如何则不得而知。似乎喜欢成熟的行为、讨厌像小孩子一样玩耍。有生日的时候收到父母送的名为安迪的毛绒玩具时说道“这是啥。没sense。不要”的传闻。然而对于食物的兴趣却仍停留在小孩的阶段，多次目击到她在学校食堂点儿童套餐的样子。不喜欢喝咖啡，就算是甜味的罐装咖啡也会令她皱眉头。虽然偶尔会见到她意外地孩子气的一面，多数情况下见到的还是她说话、待人接物彬彬有礼的样子。是一个既有成熟的一面又有稚气的一面的孩子。由于还在成长期，见到她时常有“又长高了啊”、“有些像大人的样子了”这样的感慨。一直会期待着下见到她时会长成什么样子。常穿秀兰邓波的洋装。据说都是她本人挑选的，与她自己非常相配。她的可爱让人们无论男女都会成为她的粉丝。她的志向是在大学毕业后不仅在养育她生长的微软公司的旗下工作、还要活跃于整个IT界。虽然没有问到更详细的计划，但据说是要做出能让苹果和企鹅等也能和睦相处的东西。到底会做出怎样的东西来呢？ JavaScript 在争议地区长大的17岁的女孩子。常常面无表情、谈话时总给人以一定的距离感。虽然与Java的名字很像，两个人之间却没有血缘关系。在当时Java这样的名字很流行，所以父母也给她起了类似的名字。她本人似乎对自己的名字并不在意，有时也以“ECMA”的笔名进行活动。偶尔也会被叫“JS”的外号，对此则更不在意，甚至对这种称法公然无视。她的生涯非常不幸。刚一出生祖国便爆发战争。懂事之前便母亲去世、离开了父亲。在大人们任性的争斗中，她学会了将自己藏在壳中、保护自己周围的生存之术。同年龄的女孩子随着年龄的变化都在挑战各种风格的时候，她却不顾周围的话语、一个人继续闭锁在壳中。当时就是非得这样才能生存的艰难环境。由于有了这样的儿童时期，她的说话、思考、待人接物的方式与其它的孩子都稍显不同。有很多人在与她说话时都会烦恼该怎样说才好。不过，也有人对她持有简单的一根筋的思考方式“容易接触”、“某种程度上来说，很好理解”的印象。现在，她的国家正向努力解决纷争、开拓新的居住土地的方向前进着。大人们虽然仍旧任性地互相斗争，至少在这几年里，已经没有发生像以前那样互相憎恨、互相残杀的战争了。在开始复兴的祖国里，她如今应该能幸福地生活着吧？什么时候才能看到她像同龄的女孩一样欢笑呢？ Perl Perl于1987年12月、美国的沃尔夫妇家中诞生。其父亲拉里精通计算机、语言学，母亲也从事中世纪文艺复兴和语言学专业，Perl就是在这样接受了高等教育的父母身边长大的。父亲的教育虽然严厉，却也给了Perl许多自由。父亲在教育过程中经常说的一句话是：“方法不止有一个。”（There’s more than one way to do it)想到实现什么时，达成的方法不只有一种。可以考虑各种方法。父亲的这种教育方式，对她的性格形成产生了很大的影响。“这样做的话会怎么样？”……“那样做又会如何？”……张开好奇心的翅膀长大的她渐渐发现了自己“发明”方面的天赋。绝代的发明家、Perl诞生了。从她踏上发明家的道路的20年来，其发明多达128890件（2014年1月统计数），她的发明，从没什么用处的玩具，到能解决世界上许多问题的有益的发明，应有尽有。她发明的物品的原型，全都捐赠给了CPAN博物馆，任何人都可以阅览。如今仍然不论实用与否、不断做出想做的新发明的她自打趣地在采访中说道：“我比起发明家，更像是各种破烂的生产装置。”她露出牙齿的笑容，非常振奋人心。Perl对洋装不怎么讲究，平时因为调整机械时觉得麻烦，会穿便于运动的休闲装。最近常穿的羽绒服据说是在ame横（东京上野的一条商业街）的WEGO买的。喜欢的食物是草莓。她说作业中对集中注意力而疲劳的大脑来说最适合的食物就是草莓。 C 支撑着这个世界的女神大人，也被称为“圣母大人”。关于C的出身年月没有定论。有人说她在创世纪（指1970年1月1日左右）之前就存在于这个世界，也有人说她是在稍后的1972年左右诞生的。她是女神大人，因此像“1970年左右出身的话，她现在的年龄是……”这样的想法是不信教的行为。绝对不要有这样的想法。她的名字是字母表的第三个字母“C”。据新约史书上的记载，在她之前还有叫作B的女神大人。一些资料显示“肯和丹尼斯创造了B，但对此并不满足。此后丹尼斯和其它人又合力创造了C”。世界上有许许多多她的信徒。然而在一段时间内都没有正确传达她的教诲的圣经。当初丹尼斯和布莱恩留下的诗篇虽然担负着这样的使命，人们却希望有更加明确的言语。此后有许多有识之士将各种逸闻编辑整理、编著出了正确传达她的教义的圣经。本书至今已被修订过多次，根据修订年的不同，被称作C89、C99、C11等。一般人与C不能直接对话。只有积累了足够的修行者才会被允许与C交流。修行是十分严格的，需要理解”指针的指针“之类的问题，以及要求100%地成功解决无论多么努力地修行都难以克服的“malloc/free”问题。由于这样的背景，真正能跟她进行日常交流的人非常地少。然而由能够交流的人经手、世界上诞生了多种多样的知识与技术。即使你没有见过她的样子，她的慈爱也确实地每天都围绕在你身边。 Visual Basic 姓氏是Basic，名字是Visual，也有很多人叫她的绰号：VB。小名是Ruby（与那个Ruby没有关系）。从小被某个资产家（不能说他的名字）看上，一家人都寄身于资产家的身边。那时她的名字换了好多次，如今才定下这个名字，有着比较复杂的家庭环境。关于资产家要收养尚处于幼年的她原因，据不可靠的传言称，他从她身上看到了从前就很憧憬的Basic女士的影子。收养与具有与憧憬的女性相似气质的小孩，也即实行所谓的光源氏计划。也许年轻人并不了解，Basic女士曾是《微电脑Basic杂志》的封面模特，在当时是每个人都非常向往的麦当娜一样的女性。实际上我的认识的人里面年轻时为她倾倒的人非常之多。VB在接受严格教育的同时，也在关于兴趣方面拓展天性，她在手工制品、装饰品方面有着独特的才能。看着她制作珠子的装饰品的样子会觉得犹如魔法一般。仅仅是动动手，一瞬间就可以做出一串项链。在她10岁的时候，资产家的家里来了一位新的养女。（人们常说的那位）由于这个原因，她现在正在家中努力做一位好姐姐。然而本来便懦弱、不擅长说话的她却时常反过来被小她10岁、认真的、发言时间长的妹妹说教。加油啊，VB小姐。小时候的VB会穿着父母买的Emily Temple的衣服，现在更多时候穿着是自己买的Lowrys Farm的衣服。今年就要大学毕业进入社会了，目标是VB小姐特有的成熟路线。 R 她于2000年2月29日出身。正是残存在人们记忆中400年一遇的被诅咒的那一天。虽然出身于非常不吉利的日子，她自己却成长为人见人爱的聪明的孩子。她的母亲名叫S。虽然在神话的世界里C是在B之后出生的，她的名字却是S的前一位R。这几个都是很难用Google搜出来的名字。（注：因为太短了！）她的母亲非常擅长数学，是统计学者的助手，R也继续了这一性质。她从小时候起就很擅长数学，小学时代就已经达到能快速解决高中数学问题的级别。此外，她对几何图形也很感兴趣，经常有人看到她画着各种二维、三维图形、画好后一个人露出满足愉悦的表情。是一个稍微有点奇怪的孩子。R在擅长数学的同时却也对语言表达方面稍显逊色。前些日子采访她的时候，她对提出的问题想要回答却找不着合适的词，取而代之“刷——”地画了一幅散点图说“这样的感觉”。或许在她的眼里，这个世界里用语言来表达就像折叠复杂的数学公式那样复杂吧。她对服装不怎么讲究，常常穿着不紧不松的连衣裙和衬衫。对于父母给她买的洋装是多少价格、哪儿买的这样的问题没有认识。仅仅是，对于最近买来的喇叭裙的裙摆张开的角度很在意。她的梦想是将来成为一名统计学者，尽管只有14岁却经常混迹于大学学生中间每天都在解各种问题。最近光是大学已经不能满足、又向父母请求、在各种各样的研究所里进出。 Scala O教和F教之前有着长着的宗教战争。Scala是这两个宗教的牧师和修女结婚诞生的异端。她出身后立即引起了两家之间激烈的对立，察觉到危险的父母将她送到私立JVM学校的Odersky老师那儿作为养女寄养。现在两个宗教比起当时已有了关系改善的征兆，有一部分人也将她视为两家融合的象征。然而抱有强烈的对立心态的人仍然很多，也常常有针对她的存在引起的争论。F教的人们认为她的存在没有充分认识F的本质，而O教的人则对混有F的她感到难以理解。虽然诞生于这样复杂的环境，她自己对于周围的环境却不关心，而是十分平静地到双方的教会中取面包、坚强地生活着。被她这种天真烂漫的姿态所感动、成为她的粉丝的人也很多。Scala似乎喜欢同校的高年级部里上学的Java小姐，休息时间经常去找她。Java小姐也并不讨厌她，经常会像大姐姐一样让她坐在她的膝盖上温柔地抚摸她的头。虽然在Scala把Java喜欢的Duke的人偶用红绳子绑起来进行恶作剧时把Java惹得十分生气，在此以外则几乎没怎么吵过架。两个人就好像亲生姐妹一样。有着见多识广的父亲和温柔的姐姐的Scala现在也许是，与其出身的复杂情况相反、实际上非常幸福地生活着吧。她对于洋装喜欢明快的颜色和花纹，经穿着Algonquin的衣服。虽然是比较有个性的时装，由与生俱来的有个性的她穿来却不可思议地自然。 Shell 创世纪（1970年1月1日）起经过数年后被目击到的妖精。会寄宿在家中，有着类似于棕精灵（Brownie）的生活方式，向她们拜托家务事或着杂活的时候，会回答两次并接受的温顺的孩子的。她们不常出现在人间存在的地方，因为不通言语，会用信件交流。如果拜托的事情说得比较含糊的话，有可能会造成误解而发生不得了的事情。对此的技巧是明确地像“做那个|做这个&gt;放在这里”这样有顺序地将要拜托她们做的事写好。如果对拜托的事理解得很好的话，她们会在夜里将事情都处理好。如果很好地完成了工作的话，请别忘了在第二天的晚上放上作为谢礼的方糖。Shell中有各种各样的种族。现在已确认的种族中比较有名的有：“ba”、“c“、”k”、”tc”、“z”等等。其服装根据种族不同而不同，我所目击到的是一只身高60cm左右、穿着巴宝莉的儿童服装的个体。恐怕人们目击到最多是”ba”种。个人而言我也想遇到身高更高一些、尖耳朵的“z”种，现在虽然知道如何写信，却从未见过实物。尽量她们会在同一个屋子里居住，却很少有人有机会见到，也不如何才能遇到他们。有一种说法是，每天都把写程序这一仪式进行到午夜、勉强靠咖啡因支撑着抬起头的状态下突然向屏幕看去，能够看到她的身影。确实我遭遇她，也是在公司里熬夜写程序的时候。Shell的个体非常地多，据说每家每户都会有一只。在大家的家里，实际上有着许多的她们居住着、等着来信也说不定。 ActionScript 在争议地区诞生的13岁女孩子。她的父亲是有名的设计师，但是她5岁的时候被卷入战火身亡。幸运的是她那时年纪还小、将她收养的Adobe叔叔非常用心地将她养大，没有在她心中留下很大的伤痕。叔叔和她父亲同样都是设计师。也许在她的记忆中已经把两个人混淆一起了也说不定。她所居住的国家与JavaScript所居住的国家是邻国，两国同样是ECMA人种构成的。在外国人看来JavaScript和ActionScript的外貌非常相似。确实在看她们儿童时期的照片，在肤色和五官上都很相像，但如今长大了的照片看了的话会如何呢。她把“为祖国和叔叔努力”作为座右铭努力着，然而努力却经常得不到回报，是一个运气不太好的孩子。在争论地区盛传将实行新的公用语的时候，她希望为即将到来的和平时代出一份力，比谁都更早开始学习这门语言，然而在好不容易能说好这门语言的时候，这语言被采用为公用语的提案泡汤了。在她刚开始学习移动端上的设计时，她想着在移动方面强大了会对叔叔的工作有用。也可以减少祖国的外贷。在这样的想法中努力的时候，叔叔经营的公司却被某个巨型移动终端公司强行终止的交易，关于移动端的工作也急剧减少。十分努力却常常得不到回报的她，伫立于这片如今也看到到纷争停止的土地上，继续地前进着。有朝一日努力会得到回报的吧。祝福她在10年后仍能平安，不断地前进着、生活着。]]></content>
      <categories>
        <category>冷趣小知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[（转）世界上第一位程序员竟然是个妹子]]></title>
    <url>%2F2017%2F07%2F04%2F20170704%2F</url>
    <content type="text"><![CDATA[在程序员这个男多女少的世界里，男女比例的极不均衡让男程序员们自然而然地成为了这个世界的主宰。细数下来，从C语言和Unix系统的创造者Denis和Thompson，到后来的Linux系统之父Linus，再到Java之父Gosling，都是广大男程序员中杰出代表，是程序界的豪杰。按照这种逻辑，想必世界上第一位程序员也必定是我们男同胞吧！哈哈，认真你就猜错了，据史料记载，世界第一位程序员的的确确是一个妹子，名叫阿达·洛芙莱斯(Ada Lovelace)，就是下面这位。废话少说，下面就让我们看看她是如何成为一位伟大的程序员的吧，或许如果不是她，这世界上也许就没有程序员这个职业了呢！ 我就是世界上第一位程序猿，你是第几位呢?在我看来，阿达被称为世界上最伟大的程序员是毫不为过。她为了给程序设计“算法”，制作了第一份程序设计流程图，作为计算机程序的创始人，她建立了循环和子程序等现代编程领域极为重要的概念。不过重要的是人家不仅仅是一个程序员，还擅长思考，在数学和逻辑学方面也颇有天赋，此外她的颜值也很高，美貌过人，是英国著名诗人拜伦的女儿。其实天资聪颖的她本该按照母亲的意愿成为一名数学家的，之所以变成一名程序员还得从巴贝其和他的分析机说起。出生于伦敦的阿达，在17岁时于剑桥大学第一次见到了著名的数学家、发明家兼机械工程师查尔斯·巴贝其，而这次相遇成了阿达人生的转折点。巴贝其当时正致力于发明分析机，而阿达则致力于为这台分析机编写算法。在这个过程中，阿达第一次接触到“差分机”这个概念，阿达日后的在和巴贝奇教授讨论差分机的过程中，预言了通用计算机可能。譬如她建议建议用二进制数代替原来的十进制数，表明分析机可以接受各种各样的穿孔卡：“控制卡”、“数据卡”、“操作卡”。她还提议数字和其他符号如字母都可以“编码”成数字数据，机器可以处理它们。甚至早于现代计算机出现200年，提出了分析机的记忆能力的想法，指出分析机应该有存储位置或地址，并且有“注解或备忘”的可能性。尽管由于当时技术的局限性无法满足分析机队精度，导致分析机最终无法实现，但是阿达在这个过程中提出的种种编程概念以及她对于计算的理解，对日后编程界产生了巨大的影响。从这一点上看，阿达当之无愧成为世界公认的第一位程序员。后来美国军方为了纪念阿达的杰出贡献，将历时20余年开发的一种新型的高级编程语言命名为——Ada。所以说妹子们如果以后有男程序员吹嘘自己的偶像代码写的多么厉害的时候，那就应该告诉他世界上第一位程序员还是一个妹子呢？你看她多厉害啊！你们都是跟她学的。]]></content>
      <categories>
        <category>冷趣小知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一副图片看开源]]></title>
    <url>%2F2017%2F07%2F01%2F20170701%2F</url>
    <content type="text"><![CDATA[这是一副在网络上流传多年的图片，你能看懂吗？咋一看，这是一副什么图呀？4个形象有趣的卡通人物坐在一起喝着咖啡聊着天，墙上挂着的照片又是“真人秀”，总感觉有什么寓意藏在其中……其实这幅图确实是暗藏玄机，它的场景当中暗含了许许多多软件世界中的重要技术、著名人物和组织。这些技术、人物、组织都有一个共同点，那就是“开源”。所以，我们可以说这是软件开源世界中的一个大集合。【手动微笑】 什么是开源一说到“开源”两个字，很多人的第一反应是“免费”（你们呀，真是够了……）。那么到底什么是开源呢？ 开源(Open Source)：它是软件项目上的一种公共协作，用于描述那些源码可以被公众使用的软件，并且此软件的使用、修改和发行也不受许可证的限制。 在计算机发展的早期阶段，软件几乎都是开放的，任何人使用软件的同时都可以查看软件的源代码，或者根据自己的需要去修改它。在程序员的社团中大家互相分享软件，共同提高知识水平。这种自由的风气给大家带来了欢乐，也带来了进步。 但不久之后，以微软为主的一些商业公司就破坏了这种风气。这些商业公司从自由的计算机社团里雇佣了大量的技术高手，开发带有知识产权保护的专有软件。他们在分发软件的时候也不再附带源代码。从此，专有软件的时代到来了。直到现在，专有软件不公开源代码仍是默认的行业潜规则。 即使这样，崇尚自由的斗士们也没有妥协。他们认为，数字时代本应是自由的，任何人都可以自由的获取软件资源及其源代码，而不应该被少数商业公司所控制。因此由 Stallman为领袖的一群富有激情的技术高手们发起了自由软件运动，创立了“自由软件基金会”，即Free Software Foundation(FSF)。FSF 颁发了 GNU GPL 通用公共许可，GPL 明确定义了自由软件的含义，即用户拥有使用软件、修改软件、重新发布软件以及改善再利用软件等四种自由，作为前提的，自由软件必须公开所有的源代码。 GPL 成为自由软件世界中的最高精神纲领，它成功地创建了一个软件中的自由王国，并保证开发者、用户都拥有充分的自由权。另外，在自由软件的世界中，根本就不存在盗版的概念。“自由软件”的英文是“Free Software”，这不免为许多人所误解，人们经常把它和“免费软件”连系在一起，免费的恰恰都是些低级的，这使得自由软件蒙上了一层阴影。于是大家决定给自由软件一个更易理解的别名“开源软件”。开源一词则由此得来。所以，开源即是自由的化身。它讲述了一种公开的、自由的精神。软件开源的发展历程 ，为我们软件行业以及非软件行业的人都带来的巨大的参考价值. 看图说话接下来，就让我们来认识一下这幅图当中隐藏的那些有关开源的隐藏冷趣小知识吧。 四个主角从左至右： 红色小恶魔 FreeBSD是一种UNIX操作系统，是由经过BSD、386BSD和4.4BSD发展而来的Unix的一个重要分支。FreeBSD 为不同架构的计算机系统提供了不同程度的支持。 企鹅 Linux是一种自由和开放源码的类Unix操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。Linux是一个领先的操作系统，世界上运算最快的10台超级计算机运行的都是Linux操作系统。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。Linux得名于天才程序员林纳斯·托瓦兹。 Java Duke 这个就不多说了，Java的吉祥物Duke 红色恐龙 Mozilla基金会简称Mozilla（缩写MF或MoFo），是为支持和领导开源的Mozilla项目而设立的一个非营利组织。该组织制定管理开发政策，经营关键基础组织并管理商标及其他知识产权。它拥有一个称作Mozilla公司的子公司，雇佣了一些Mozilla开发人员并协调Mozilla Firefox网页浏览器以及Mozilla Thunderbird电子邮件客户端的发行版。 背景墙从左至右： 第一幅照片 理查·马修·斯托曼（Richard Matthew Stallman）是美国自由软件运动的精神领袖、GNU计划以及自由软件基金会（Free Software Foundation）的创立者。作为一个著名的黑客，他的主要成就包括Emacs及后来的GNU Emacs，GNU C 编译器及GDB 调试器。他编写的GNU通用公共许可证（GNU GPL）是世上最广为采用的自由软件许可证。 第二副照片 詹姆斯·高斯林 （James Gosling），软件专家，Java编程语言的共同创始人之一，一般公认他为“Java之父”。 牛头 GNU计划，有译为“革奴计划”，是由理查德·斯托曼在1983年9月27日公开发起的自由软件集体协作计划。它的目标是创建一套完全自由的操作系统GNU。 日历 Evolution是Linux的邮件客户端，为gnome桌面环境下电子邮件、个人信息、日程安排、日历等方面提供了一整套高效的解决方案，多年来一直受到linux用户的好评。 壁炉上的摆件骆驼摆件 Perl语言，最初的设计者为拉里·沃尔（Larry Wall），他于1987年12月18日发表。Perl借取了C、sed、awk、shell scripting以及很多其他程序语言的特性。其中最重要的特性是它内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN。简而言之，Perl象C一样强大，象awk、sed等脚本描述语言一样方便。Perl 一般被称为“实用报表提取语言”（Practical Extraction and Report Language），你也可能看到“perl”，所有的字母都是小写的。一般，“Perl”，有大写的P，是指语言本身，而“perl”，小写的p，是指程序运行的解释器。 ####鱼缸中的河豚####OpenBSD是一个多平台的，基于4.4BSD的类UNIX操作系统，是BSD衍生出的三种免费操作系统（另外两种是NetBSD和FreeBSD）之一，被称为世界上最安全的操作系统。 餐桌摆件咖啡杯 Java语言的Logo，就不多说了。 笔筒图案 GIMP 是跨平台的图像处理程序。GIMP 是 GNU 图像处理程序(GNU Image Manipulation Program)的缩写。包括几乎所有图象处理所需的功能，号称Linux下的PhotoShop。 羽毛 Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。 彩色方块 GTK+（GIMP Toolkit)是一套源码以LGPL许可协议分发、跨平台的图形工具包。最初是为GIMP写的，已成为一个功能强大、设计灵活的一个通用图形库，是GNU/Linux下开发图形界面的应用程序的主流开发工具之一。并且，GTK+也有Windows版本和Mac OS X版。 白色方块 XOrg基金会的X11开源实现 （XOrg Foundation Open Source Public Implementation of X11） (the XOrg Server) 是X Window System的官方参考实现。当前的发布版本是X11R7.0，发布于2005年2月10日。它是开放源代码的自由软件。这个项目由X.Org基金会运作，存放于freedesktop.org的主机上。 便签本 OpenOffice.org 是一套跨平台的办公室软件套件，能在 Windows、Linux、MacOS X (X11)、和 Solaris 等操作系统上执行。它与各个主要的办公室软件套件兼容。OpenOffice.org 是自由软件，任何人都可以免费下载、使用、及推广它。 桌布脚印图案 GNOME是一种让使用者容易操作和设定电脑环境的工具，GNOME 包含了 Panel （用来启动此程式和显示目前的状态）、桌面 （应用程式和资料放置的地方）、及一系列的标准桌面工具和应用程式，并且能让各个应用程式都能正常地运作。不管之前使用何种操作系统，都能轻易地使用 GNOME 功能强大的图形接口工具。]]></content>
      <categories>
        <category>冷趣小知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[什么！你用的Java版本叫“Tiger🐯”？]]></title>
    <url>%2F2017%2F06%2F28%2F20170628%2F</url>
    <content type="text"><![CDATA[作为一个Java初学者，很多同学的精力都放到了Java语言本身的语法当中，或是开始纠结于各种算法，或是专研OO思想，还有人对各种设计模式趋之若鹜，总之开启了各种“高大上”的装逼模式……少年人，你可知道： “生活不止眼前的苟且，还有诗和远方的田野。”———————— 高晓松 今天就让我们先放下冷冰冰的代码，虚无缥缈的编程思想，来看点关于Java你应该知道的一些“趣知识”吧。 Java之父 这位看上去亲切和蔼的“花样”大叔，相信很多人都认识。他就是著名的Java之父—-詹姆斯.高斯林（James Gosling）。别看人家现在是一脸沧桑，想当初也是以一个“天才”少年的身份闪亮登场的。1955年的冬天，詹姆斯出生在加拿大的一个村庄里。12岁的时候，他用报废的电话机和电视机中的部件做了一台电子游戏机。附近农民的联合收割机出了问题也常常找他修理。14岁的时候，中学组织到附近大学参观，他记住了大学计算中心的门锁密码，从此开始偷偷地溜进计算中心，学习计算机编程。一年后（15岁），大学的天文系招他当了一名临时编程员，编写计算机程序来分析卫星天文数据。1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位。毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司。1990年，与Patrick Naughton和Mike Sheridan等人合作“绿色计划”，发展了一套语言叫做“Oak”，后改名为Java。1994年底，在硅谷召开的“技术、教育和设计大会”上詹姆斯.高斯林展示了Java程序。2000年，Java成为世界上最流行的电脑语言。2009年4月，甲骨文公司花费了74亿美元收购了SUN公司。但由于理念不合，不到一年詹姆斯.高斯林宣布从甲骨文公司离职。2011年3月29日，他在个人博客上宣布将加入谷歌，但几个月以后他又离开了。2011年8月30日，他加盟一家从事海洋机器人研究的创业公司Liquid Robotics，担任首席软件架构师。2017年5月22日，詹姆斯在Facebook上宣布他将加入到亚马逊。厉害吧👍👍👍，这位60多岁的IT大牛太能折腾了。有这么一位祖师爷，各位Java学员你们还怕什么？！😏😏😏 Java吉祥物说到Java，所有同学都应该认识那杯热气腾腾的咖啡杯，那么下面这个小家伙你认识吗？ 它叫做Duke（杜克），是由Joe Palrang在1992年创作出来的。Duke当时所扮演的角色是类似Office中小助手的功能，而那时的Java这门编程语言还不叫Java而被称之为Oak呢。另外大家也许都知道Java是开源的，那你知道Duke也是开源的吗？也就是说我们可以随意发挥我们的想象力，让Duke飞起来✈️～～～ Java全球排名Java初学者常常被教导说：Java是最流行的语言。说这话的人往往是微微一笑，高深莫测的样子；听这话的则是将信将疑，你们是不是王婆卖瓜，自卖自夸呀……那么编程语言有没有排名呢？谁排的，咋排的呢？其实在业内，我们还真有一个可靠的编程语言榜单，它叫做TIOBE排行榜。该榜单是根据互联网上有经验的程序员、课程和第三方厂商的数量，并使用搜索引擎（如Google、Bing、Yahoo!）以及Wikipedia、Amazon、YouTube统计出排名数据。其目的只是反映某个编程语言的热门程度，并不能说明一门编程语言好不好，或者一门语言所编写的代码数量多少。TIOBE开发语言排行榜每月更新一次排名，每年评选一个年度语言。我们来看看目前的最新排名情况： 给你个网址，可以随时可以查看：TIOBE排行榜单; Java版本演化及别名JDK1.0这是第一个发布的版本，发布时间是1996-1-23。当时语言的名字还被叫做Oak（橡树）。直到第一个稳定版本JDK1.0.2被发布出来，才被称之为Java。 JDK1.1这个版本发布的时间在1997-2-19，它主要添加的内容包括： 改进扩展了AWT的事件模型 添加了内部类 引入JDBC（Java数据库连接） 引入RMI（远程方法调用） 引入反射机制 在微软的Windows平台上引入JIT编译器（Just in Time，及时编译器）。 开始支持国际化和Unicode编码 J2SE1.2这是Java历史上的一个“里程碑”式的版本。它发布于1998年12月8日，并且从这个版本开始出现了几个名称上的变化： 从这个版本开始直到J2SE5.0，Java被更改为Java2； 从这个版本开始，版本名称从JDK改为J2SE，以便于区分其它扩展平台J2ME、J2EE。 从这个版本开始，开始公布每个Java版本的开发代号。J2SE1.2的开发代号是“playground”（操场）。意味，SUN公司给各位Java程序员提供了一个广阔的平台，大家High 起来。 这个版本提供的新内容包括： 增加strictfp关键字； 核心类中融入Swing图形API； SUN公司的JVM（Java虚拟机）首次装备JIT编译器； 引入集合框架； 引入Java插件applet支持； Java IDL（交互式数据语言），支持CORBA。 J2SE1.3开发代号为Kestrel（红隼），发布于2000年5月8日。引入新特性包括： HotSpot JVM首次被包含（发布是在1999年4月份）； 修改RMI，使其支持CORBA； JNDI（Java命名与目录接口）被包含在核心库当中； 引入JPDA（Java平台调试体系）； 引入Java声音API； 引入动态代理类。 J2SE1.4开发代号为Merlin（灰背隼），发布于2002年2月6日。引入新特性： 增加assert关键字； 引入正则表达式； 引入链式异常处理； 提供IPV6的支持； 提供非阻塞的输入输出（被称之为新的IO，NIO）； 提供日志API； 提供Image IO API支持读写格式为JPEG和PNG的图片； 提供XML解析和XSLT的处理； 引入安全和密码表达式； 引入Java Web Start； 引入Preferences API。 J2SE5.0开发代号为Tiger（老虎），发布于2004年9月30日。这个版本是Java版本史上第二个“里程碑”式的突破，它不断更新，一直持续到2009年年底，经历了Orcale收购SUN这一重大事件。在名称上，也经历了从原本的J2SE1.5更改为J2SE5.0，到JavaSE5这一系列的变化。引入新特性： 引入泛型； 增强循环，可以使用迭代方式； 自动装箱与自动拆箱； 类型安全的枚举； 可变参数； 静态引入； 元数据（注解）； 引入Instrumentation。 JavaSE6开发代号为Mustang（野马），于2006年12月11日发行，直到2017年1月17日。引入的新特性包括： 支持脚本语言； 引入JDBC 4.0 API； 引入Java Compiler API； 可插拔注解； 增加对Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access Protocol)的支持； 继承Web Services； 深入优化。 JavaSE7开发代号为Dolphin（海豚），于2011-07-28发行，直到2017-1-17。引入新特性： switch语句块中允许以字符串作为分支条件； 在创建泛型对象时应用类型推断； 在一个语句块中捕获多种异常； 支持动态语言； 支持try-with-resources； 引入Java NIO.2开发包； 数值类型可以用二进制字符串表示，并且可以在字符串表示中添加下划线； 钻石型语法； null值的自动处理。 JavaSE8开发代号为Spider（蜘蛛），于2014年3月18直到如今。引入新特性： Lambda表达式 Stream函数式操作流元素集合 接口新增：默认方法与静态方法 方法引用,与Lambda表达式联合使用 引入重复注解 类型注解 最新的Date/Time API (JSR 310) 新增base64加解密API 数组并行（parallel）操作 JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）元空间]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[打印万年历，你会吗？]]></title>
    <url>%2F2017%2F06%2F25%2F20170625%2F</url>
    <content type="text"><![CDATA[打印万年历，你会吗？啊，不会！那就跟我一起使用Java在控制台上打印一个简单的万年历吧！ 这个万年历怎么样，漂亮吧！ 你该不会天真的认为这是从控制台上打印出来吧？要是你真这么想，我可被你的天真打败了！ 要用Java实现这个万年历不是不可能，你还得会Java的swing图形用户界面开发。 我们还是来看看Java在控制台上打印的万年历长啥样？ 第一反应是不是好丑呀？别看它长得丑，这可是货真价实的万年历。 软件开发其实就好比一个人，最重要的是内涵(功能），而不是外表(界面）（其实外表也很重要）。这个万年历就很有内涵。不信，我们就一起来看一看如何实现万年历吧。 初学编程的同学在写代码时，习惯还没想好就开始写代码，写的过程中有问题又反复修改。如果是语文考试作文，恐怕你的作文最终已经改得面目全非，惨不忍睹。所以，这是一个非常不好的编程习惯。 好的编程习惯是解决问题前一定要先分析问题，把大问题逐步分成小问题，理清逻辑，自下而上，逐步实现。 其实，一句话就是先想好再动手。 问题分析 首先1970年是Unix系统诞生的时间，1970年就成为Unix的元年，1970年1月1号是星期四，现在大多的手机的日历功能只能显示到1970年1月1日这一天。不信，现在赶紧掏出手机看一看。那最大可以显示哪一年呢？我的手机显示的是2037年，你的呢？ 要想打印某年某月的日历，逐步分成小问题如下： 1&gt; 计算出本月的总天数 （注意：考虑闰年问题） 2&gt; 计算出本月的1号是星期几（其他号数对应的星期几就可以以此类推） 打印万年历格式 1&gt;打印标题格式 2&gt;打印内容格式 代码实现问题分析得差不多了，心里应该大致知道要实现哪些小功能，接着就一步步编写代码。 Java的JDK帮助文档中，有一个专门日历类－Calender。这个类封装了很多方法用于计算日历，我们正好使用它来完成万年历的开发。 下面写一个Calender简单小例子： 12345678public static void main(String[] args) &#123; Calendar nowc = Calendar.getInstance(); System.out.println(nowc.get(Calendar.YEAR)); // 当前年份 System.out.println(nowc.get(Calendar.MONTH));// 当前月份（从0开始) System.out.println(nowc.get(Calendar.DAY_OF_MONTH)); // 当前日期 System.out.println(nowc.get(Calendar.DAY_OF_WEEK)); //当前星期几（从1表示星期日开始） &#125; 输出结果如下（2017年6月9日 星期五）： 2017 5 9 6 Calendar类在实现万年历中的具体使用，我们通过代码进行说明，方法的使用有不清楚的地方可以自行查看JDK帮助文档。 判断是否闰年方法 1234567// 判断闰年（年份能被400整除或能被4整除同时不能被100整除）public static boolean isLeap(int year) &#123; if ((year % 400 == 0) || ((year % 4 == 0) &amp;&amp; (year % 100 != 0)))&#123; return true; &#125; return false;&#125; 计算本月天数 1234567891011121314151617// 计算本月天数public static int getDays(int year,int month) &#123; int days = 0; if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) &#123; days = 31; &#125; else if (month == 4 || month == 6 || month == 9 || month == 11) &#123; days = 30; &#125; else &#123; if (isLeap(year)) &#123; //判断是否闰年 days = 28; &#125; else &#123; days = 29; &#125; &#125; return days;&#125; 计算本月第一天星期几 123456789// 计算本月一号星期数public static int getfirstWeek(int year,int month) &#123; Calendar calendar = Calendar.getInstance(); calendar.set(year, month-1,1); //设置日期为本月一号 int week = calendar.get(Calendar.DAY_OF_WEEK)-1; return week;&#125; 打印标题 1234567891011// 打印标题public static void printTitle(int year, int month) &#123; System.out.printf("%32s\n", year + " 年 " + month + " 月 "); System.out.println("----------------------------------------------"); String[] weeks = &#123; "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" &#125;; for (int index = 0; index &lt; weeks.length; ++index) &#123; System.out.printf("%-15s", weeks[index]); &#125; System.out.println();&#125; 打印内容 123456789101112131415161718// 打印内容public static void printBody(int year,int month) &#123; int week = getfirstWeek(year, month); for (int index = 0; index &lt; week; ++index) &#123; String blank = " ";// 空字符串占位 System.out.printf("%-8s", blank); &#125; int days = getDays(year, month); for (int index = week+1,day = 1; index &lt; days + week+1; ++index,day++) &#123; if (index % 7 == 0) &#123; System.out.printf("%-8d\n",day); //换行 &#125; else &#123; System.out.printf("%-8d",day); &#125; &#125;&#125; 打印万年历 1234567891011121314151617//打印万年历public static void main(String[] args) &#123; // 控制台输入年份和月份 Scanner input = new Scanner(System.in); System.out.println("请输入年份："); int year = input.nextInt(); System.out.println("请输入月份："); int month = input.nextInt(); // 打印标题 printTitle(year, month); // 打印内容 printBody(year, month);&#125; 总结你现在觉得打印这个简单的万年历其实并不简单，很有内涵了吧？涉及很多编程的细节和小问题的处理。是不是感觉一下子脑袋又不够用了？ 还等什么，现在就跟着上面的代码，自己再敲一遍。边敲那思考，直到自己搞明白为此。]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[你应该知道的Java创建对象的四种方式]]></title>
    <url>%2F2017%2F06%2F22%2F20170622%2F</url>
    <content type="text"><![CDATA[面向对象程序设计(OOP)是当今主流的程序设计规范，它已经基本取代了结构化、过程化的程序设计。Java就是面向对象的，使用java开发程序，不管做什么样的操作，我们第一步都是从创建对象、获取对象开始，有了对象我们就可以完成一切我们所需要的程序了。 那怎么样才能创建对象？java中有哪些创建对象的方法？我们今天就来详细了解一下。 一：new运算的方式创建对象首先我们有一个关于宠物的类Dog1234567public class Dog &#123; String name; int age; public void show()&#123; System.out.println("我叫"+this.name+"今年"+this.age+"岁了"); &#125;&#125; 当我们程序中需要出现一只狗狗的时候，我们就可以使用new来创建一个具体的对象了123Dog dog1=new Dog();dog1.name="xiaohei";dog1.age=3;在这里我们就通过了new的方式获得了一个具体的对象，并且起名为小黑，年龄为3岁。 现在，dog1就带表了堆中刚才所实例化出来的对象。以后我们要操作刚才new出来的对象就可以通过dog1来操作了，例如我们让小狗打个招呼(调用Dog类的show方法)：1dog1.show(); 二：通过反射的方式创建对象Java的反射技术是java程序的特征之一，它允许运行中的Java程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性。 反射的作用：1）可以通过反射机制发现对象的类型，找到类中包含的方法、属性和构造器2）可以通过反射创建对象并访问任意对象方法和属性 第二种创建java对象的方式就是通过反射来创建了。 还是我们之前用过的Dog类，首先JVM利用ClassLoader(类加载器)先将Dog类加载到内存，然后马上产生了一个Class类型的对象，该对象可以看成是一个模型，以后无论创建多少个Dog类的实例都是利用该模型来生成(一个类所对应的Class类型的对象只有一个)。 通过反射创建对象第一步：需要获得class对象1Class clazz = Dog.class; 这样获取到类对象之后就可以通过newInstance()这个方法来获取具体的对象了，需要注意的是这个方法的返回值是Object类型，我们需要进行转型操作12Class clazz = Dog.class;Dog dog = (Dog)clazz.newInstance();这样我们就通过反射的方式创建好了java对象,newInstance()和new的区别如下： newInstance: 弱类型。低效率。只能调用无参构造。new: 强类型。相对高效。能调用任何public构造。 在这里需要注意的是，newInstance()这个方法只能够调用无参的构造函数(其实这也符合javabean规范，一个类必须拥有一个无参构造函数)，现在我们在Dog类中写有参构造函数(默认覆盖无参构造函数)，值得注意的是，当我们写了有参构造函数之后，系统将不再提供默认的无参构造函数，如果需要的话，需要你自己写12345678public class Dog &#123; String name; int age; public Dog(String name,int age)&#123; this.name=name; this.age=age; &#125;&#125;现在再去调用newInstance()方法12Class clazz=Dog.class;Dog dog=(Dog) clazz.newInstance(); 现在程序运行结果为java.lang.InstantiationException，着就是程序没有无参构造函数而使用newInstance()方法引发的错误了 当然如果你需要调用有参构造函数的话，可以通过以下的办法：1234Class clazz=Dog.class;Constructor constructor=clazz.getConstructor(String.class,int.class&#125;);Dog dog=(Dog) constructor.newInstance("xiaohei",3&#125;);System.out.println(dog.name+" "+dog.age); 程序的第二行我们调用Class对象的getConstructor方法，然后在参数列表中传入String和int，因为我们的有参构造函数的参数列表就是这样规定的，现在我们就获取到了前边定义好的Dog类的有参构造函数了第三行我们通过获取的Constructor对象调用newInstance方法，然后在方法中传入Object类型的参数列表，因为我们的有参构造函数需要这些值，这样就可以通过反射的方式创建只有有参构造函数的对象了 三：通过对象反序列化的方式来创建当我们使用反序列化一个对象的时候，JVM会给我们创建一个对象。但是，反序列化的时候JVM并不会去调用类的构造函数(前边两种方式都会去调用构造函数)来创建对象，而是通过之前序列化对象的字节序列来创建的。 序列化对象必须实现Serializable这个接口把对象转为字节序列的过程称为对象的序列化把字节序列恢复为对象的过程称为对象的反序列化 1234567public class Dog implements Serializable&#123; String name; int age; public void show()&#123; System.out.println("我叫"+this.name+"今年"+this.age+"岁了"); &#125;&#125; 需要注意的是：Dog类需要实现Serializable这个接口才可以被序列化/反序列化，否则会出现java.io.NotSerializableException异常 对象序列化通常有两种用途： 1）将对象的字节序列永久的保存到硬盘上例如web服务器把某些对象保存到硬盘让他们离开内存空间，节约内存，当需要的时候再从硬盘上取回到内存中使用 2）在网络上传递字节序列当两个进程进行远程通讯的时候，发送方将java对象转换成字节序列发送(序列化)，接受方再把这些字节序列转换成java对象(反序列化) 当Dog类实现了Serializable接口后，我们现在将Dog对象序列化1234567Dog dog=new Dog();dog.name="xiaohei";dog.age=3;FileOutputStream fos = new FileOutputStream("dog.txt");ObjectOutputStream ops = new ObjectOutputStream(fos);ops.writeObject(dog);System.out.println("dog对象序列化完成");通过ObjectOutputStream的writeObject方法，我们就将一个对象完成了序列化 现在我们再次将刚才序列化后的对象反序列化回来，这次用到的是ObjectInputStream的readObject方法：12345FileOutputStream fos=new FileOutputStream("dog.txt");ObjectInputStream ois=new ObjectInputStream(fos);Dog dog=(Dog) ois.readObject();System.out.println("我叫"+dog.name+"今年"+dog.age+"岁了");System.out.println("对象反序列化完成"); 这样我们就使用了对象的序列化完成了java对象的创建 四：通过clone的方式来创建clone方法来源于java中object类，在jdk中的解释为：该方法返回一个此对象的副本。clone顾名思义就是复制的意思。所谓复制对象就是在内存中分配一个和原一模一样的空间，在此创建新的对象。 我们现在就来完成clone的实验，首先我们需要在需要clone的类中实现Cloneable接口，否则会出现java.lang.CloneNotSupportedException异常,由于Object类中clone方法是protected 修饰的，所以我们必须在需要克隆的类中重写克隆方法12345678910 public class Dog implements Cloneable&#123; String name; int age; @Override protected Object clone() throws CloneNotSupportedException &#123; //TODO Auto-generated method stub return super.clone(); &#125;&#125;现在进入实验1：123Dog d1=new Dog();Dog d2=d1;System.out.println(d1==d2);返回值为true，因为在这个地方只有d1是真实创建了对象，d2来源于d1的赋值，引用地址值一样(代表是同一个对象)，所以==判断结果为true 现在进入实验2：1234 Dog d1=new Dog();Dog d2=(Dog) d1.clone();System.out.println(d1==d2); 实验结果为false，因为clone是真实在内存中重新划分一块区域来存储新的对象，d1和d2是两个不同的对象所以返回结果值为false 这样我们就使用了对象的克隆的方式完成了java对象的创建]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试经典问题，谈谈你对OOA,OOD,OOP的理解]]></title>
    <url>%2F2017%2F06%2F19%2F20170619%2F</url>
    <content type="text"><![CDATA[OOA（面向对象分析）、OOD（面向对象设计）、OOP（面向对象编程），这3个概念，对于我们JAVA程序员来讲，或多或少应该都有所了解，或者说至少都听说过。但是要谈到对其理解，可能对于多数入行不深的从业者来说，确实不是那么容易做到。特别是对于绝大多数的3年以内的低中级软件工程师而言。因为他们的工作更多是需要按照项目经理分配的任务来编写功能代码，很少有多余的时间去阅读或者思考一些概念性的东西。说起这个问题，我也在网络上也搜索过很多的资料，大多摘录至书籍，比较官方化。让初学者无从理解。为了广大的新从业者或者应聘者，在这里，我们以一种实例的方式来对这3个概念进行重新的阐述： 业务场景：建行卡持有者，张三与李四两人，现在需要张三给李四转账人民币5000元整。按照业务分析后的流程图如下: 对于分析业务流程，常见的2种：面向过程分析（POA），面向对象分析（OOA）面向过程分析（Procedure Oriented Analysis）：是一种以过程为中心的编程思想，以数据流向为主要导向。为了解决问题，将解决问题的业务过程，按照一定的顺序划分成为一个又一个的事件，然后再封装成一个又一个的函数，最后由一个函数统一的按照顺序一步一步的调用即可。在面向过程分析中，顺序很重要，要实现功能只需要按照一定的顺序相互调用函数即可。 上述业务场景按照面向过程分析出来的结果就是： 程序检查张三卡中余额是否足够5000元人民币（事件1，满足则调用事件2） 程序从张三卡中扣除5000元人民币（事件2） 程序向李四卡中加入5000元人民币（事件3） 程序检测李四卡中是否正常入账（事件4，满足则结束整个业务） 程序向张三卡中加入5000元人民币（事件5） 在上述过程中，我们将这个业务过程，分成了5个步骤，也叫做5个事件，那么如果需要在程序中完成该转账业务的话，那么我们只需要按照1-2-3-4-5这样的顺序依次调用函数方法即可。在这个过程中，你会发现我们函数调用的顺序一定是不能变化的，变了就出问题了…… 面向对象分析（Object Oriented Analysis）:是一种以对象为中心的编程思想。利用从问题域中的词汇表中找到类与对象。那么说到这里，很多人对问题域又不是很清楚了，问题域：说的简单直接一点，问题域就是客户告诉你的要求，他要干什么。问题域并不特指需求，很多时候，客户所提的需求很多地方都有关联，所以在很多场合，客户所提的需求，还需要需求分析师多角度的帮助客户理清与完善。那么在客户需求范围中，衍生出来的他想要告诉你做的事，就是问题域，包括后期需求发生的变化，同样隶属于问题域的范围。用一个图来表示：需求分析文档，规格说明文档，以及程序之间的关系： 从上述业务场景的分析中，我们可以抽离出的类与对象有：抽离出来的类型有：汇钱者类，收钱者类，货币类。而张三只能算是汇钱者类中的一个实例，也被称之为汇钱者对象，李四只能算是一个收钱者类中的一个实例，也被称之为收钱者对象。那么额度为5000的人民币也只是货币类的一个具体实例。通常汇钱者类，收钱者类，货币类，我们都统一称之为：领域模型类，张三，李四，5000元人民币我们都统一称之为：领域对象。作为面向对象分析来说，我们最为重要的就是要分析出领域对象的行为。领域对象的行为主要是为后期的面向对象设计（OOD）提供接口依据，而属性作为分析阶段不是我们的重点。就上述3种领域对象而言，张三这个实例，可以查询自己卡中余额，可以从余额中取出5000元，也可以将外来的钱加入到自己的账户中。李四这个实例，可以查询自己卡中余额，可以将外来的钱加入到自己的账户中。而5000元人民币只是数据的传输携带者，没有任何行为可言。 在JAVAEE项目中，组织业务逻辑的方式：事务脚本（面向过程设计 POD）、领域模型（面向对象设计 OOD）事务脚本（面向过程设计 POD）：它是纯面向过程的一种组织业务逻辑的方式，在JAVAEE项目，是一种非常常见的设计方式，做法很简单，将POA分析后的结果封装成JAVA对应的方法即可，然后在业务层中统一按照顺序调用接口。将领域对象（人民币）去掉行为，只保留属性即可，用于数据传输。以数据流向为主要导向。 按照上述的业务场景来设计：保留失去行为的领域对象（人民币），同时抽离出一个业务层的接口类，多个持久层的数据访问接口类，在业务层接口中提供一个统一的业务调用方法transferAccount(),在数据库发生关系的持久层，提供一系列事件方法：queryBalance(),reduceBalance(),increaseBalance();使用UML类图表示为： 当然还有一系列的表示手段，比如：包图，对象图，序列图，用例图…… 这里就不一一设计了。 领域模型（面向对象设计 OOD）（Object Oriented Design）：主要是正确有效的构造出复杂系统的抽象结构，将面向对象分析后的结果，作为面向对象设计的模型，通常用于展示被设计系统的逻辑模型（业务逻辑如何设计），物理模型（系统如何划分，层次如何划分，如何部署……），静态模型（组成系统的元素：类，接口）和动态模型（对象的调用……）。将OOA分析的结果作进一步的规范化整理，以便能够被OOP直接接受。 概念可能比较生硬，那么说的直白点，设计阶段的任务就是： 按照面向对象的方式将系统分解成不同的模块化，或者系统再次划分为子系统，直到划分到可设计的最小粒度为止【垂直分块，水平分层】。 使用不同的表示方法来展示被设计系统的逻辑模型（业务逻辑如何设计），物理模型（系统如何划分，层次如何划分，如何部署……），静态模型（组成系统的元素：类，接口）和动态模型（对象的调用……）【常用的表示法手段：UML各种图形】。 需要注意的是：层次结构并非就一定是三层结构，也可以是多层，具体分几层需要根据项目的复杂度来决定，如果没有过多的业务逻辑，只有简单的CRUD的话，那么三层结构足以应付一切。 按照上述的业务场景来设计：对于领域逻辑来说，三层结构就不能满足其业务逻辑复杂度了，可能这时整个系统可能是四层，五层，或者多层……，我们这个例子，暂时定为四层结构：控制层、业务层、领域逻辑层、数据访问层。在设计领域对象时，保留失去行为的领域对象（人民币），转钱对象，收钱对象，同时抽象出一个业务层的业务接口用于简单的调度业务逻辑，多个持久层的数据访问接口类。 在OOA阶段，我们分析出张三这个实例，可以查询自己卡中余额，可以从余额中取出5000元，也可以将外来的钱加入到自己的账户中。那么它就应该对应着对应的3种行为方法。李四这个实例，可以查询自己卡中余额，可以将外来的钱加入到自己的账户中，那么它就应该对应着对应的2种行为方法。而5000元人民币只是数据的传输携带者，没有任何行为可言 如果采用UML中类图的表示法来看，图形应该如下：（在同一个图中，相同名称的元素代表同一元素）在这张图中，我们的层次就是4层结构，甚至我们还可以再分为5层，6层等，所以一般领域模型适用于业务需求较为复杂的情况。业务层仅仅是为了梳理业务流程，而真正的业务逻辑则交由领域层的领域对象之间相互调用对方的方法来实现业务逻辑。比如要转钱，就需要转钱者领域对象，减少自己的余额后，调用收钱者领域对象，添加自己的余额。当然真正的银行转钱复杂度，绝对远高于这个场景。 还需要使用到事件驱动模型，以及消息队列等一系列的技术，当然具体情况具体分析。 面向对象编程（OOP）面向对象编程（Object Oriented programming）：将面向对象设计后的抽象，采用面向对象的方式来实现的方法，就叫做面向对象编程。在这种方法中，程序被组织成许多相互协作的对象，每个对象都是一个类的实例。利用对象构成业务逻辑的组成基本元素（组合模式的层次结构），而不是采用算法。组成程序的基本元素是一个又一个的基础组件（类），那么组件就是我们层次结构所对应的接口或接口的实现类，那么程序就是由一个又一个实现类的实例相互协作来完成业务逻辑的实现。 总体来说： 面向对象分析的结果可以作为面向对象设计的模型，而面向对象设计的结果则可以作为面向对象编程的蓝图，应用程序需要由编程才能实现。]]></content>
      <categories>
        <category>OOAD</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[异常处理概述]]></title>
    <url>%2F2017%2F06%2F16%2F20170616%2F</url>
    <content type="text"><![CDATA[1.1 异常的概念异常指的是运行期出现的错误，也就是当程序开始执行以后执行期出现的错误。出现错误时观察错误的名字和行号最为重要。在这个世界不可能存在完美的东西，不管完美的思维有多么缜密，细心，我们都不可能考虑所有的因素，这就是所谓的智者千虑必有一失。同样的道理，计算机的世界也是不完美的，异常情况随时都会发生，我们所需要做的就是避免那些能够避免的异常，处理那些不能避免的异常。这里我将记录如何利用异常还程序一个“完美世界”。 异常情况例如： 工厂生产，原料用尽 高速路上车没油 家里灯泡断电 1.2 异常分类 错误: 错误不是异常，是用户和程序无法控制的问题，这是系统内部的错误。 检查异常: 检查异常通常是用户错误或者不能被程序所预见的问题，例如，打开一个文件，但是文件不存在，这中错误称为检查异常，必须由java语言来处理。 运行时异常: 运行时异常是程序在运行过程中可能发生的，可以被程序员避免的异常，可以被忽略，提示我们开发人员进行处理。 1.3 异常的控制流程首先来看一段代码：12345678910111213141516171819202122232425262728public class Demo01 &#123; public static void main(String[] args) &#123; System.out.println("进入main方法"); method1(); System.out.println("退出main方法"); &#125; public static void method1()&#123; System.out.println("进入method1方法"); method2(); System.out.println("退出method1方法"); &#125; public static void method2()&#123; System.out.println("进入method2方法"); System.out.println("excute method2"); System.out.println("退出method2方法"); &#125;&#125;进入main方法进入method1方法进入method2方法excute method2退出method2方法退出method1方法退出main方法 总结：方法调用栈中的顺序为先进后出。 上面的三个方法都被押入到内存的方法栈中，如果说某一段代码出现了异常那代码会如何执行呢？123456public static void method2()&#123; System.out.println("进入method2方法"); int n = 10/0; System.out.println("退出method2方法");&#125; 在method2中加入了 int n ＝ 10/0；程序运行到这句话是肯定要抛出异常。那我们会得到什么结果呢？ 123456789 Exception in thread "main" 进入main方法进入method1方法进入method2方法java.lang.ArithmeticException: / by zero at com.lovo.test.Demo01.method2(Demo01.java:17) at com.lovo.test.Demo01.method1(Demo01.java:12) at com.lovo.test.Demo01.main(Demo01.java:6) main方法在调用栈的最底部，method2在最顶部，如果method2抛出一个异常，method2就会从栈中被取出， 同时将异常继续抛给调用他的method1方法，发现method1并没有处理这个异常，那直接抛给main方法，并从栈中退出。 这时main方法方法也没有处理异常，就有java虚拟机来处理这个异常，虚拟机会创建一个exception对象将信息打印到控制台，然后结束程序。 通过画图来分析异常抛出的流程！ 1.4 异常的体系结构 通过api来进行异常类的查看和分析。 1.5 捕获异常在网上看了这样一个搞笑的话：世界上最真情的相依，是你在try我在catch。无论你发神马脾气，我都默默承受，静静处理。对于初学者来说异常就是try…catch如果我们发现程序某段代码会抛出异常，那我们要去捕获这个异常。 Java异常处理的五个关键字：try、catch、finally、throw、throws 例子：12345678910111213141516171819202122232425/** * 定义一个try块 * 在try块中定义两个变量，int x，int y； * 每次循环，x－－ y+＝10/x； * catch块捕获异常，如果出现异常那就输出 异常 * 返回一个y的值 * @return */public int test()&#123; try &#123; int x = 100; int y = 0; while(x&gt;-1)&#123; x--; y +=100/x; &#125; return y; &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println("执行try循环抛出异常了"); return -1; &#125;&#125;多个catch块使用12345678910111213141516171819202122232425 /** * 如果有多个catch块，一定要注意异常的类型必须从小到大的定义，从子类父类 */public void test()&#123; try &#123; Scanner sc = new Scanner(System.in); System.out.println("请输入一个数字"); int num = sc.nextInt(); int res = 100/num; &#125;catch (ArithmeticException e) &#123; System.out.println("输入的数字不能为0"); &#125;catch (InputMismatchException e) &#123; System.out.println("请输入数字"); &#125;catch (Exception e) &#123; System.out.println("未知的错误"); &#125; finally&#123; System.out.println("代码执行完毕，即将保存数据"); &#125; &#125; 1.6 申明并抛出异常1.6.1 throw和throwsthrow：将异常进行抛出（动作） throws：声明将要抛出何种类型的异常（声明） 例子： 12345678910111213141516171819 /** * throws Exception代表当前方法一旦发生异常将这个异常抛给调用中进行处理 * 如果不知道具体什么异常，可以用exception来代替 * throw 就表示执行抛出异常这个动作 * @throws Exception */public static void method2(int m) throws Exception&#123; System.out.println("进入method2方法"); if(m==0)&#123; throw new Exception(); &#125;else&#123; int n = 10/m; &#125; System.out.println("退出method2方法");&#125; 在method方法里面就必须要处理这个异常 123456789101112 public static void method1()&#123; System.out.println("进入method1方法"); try &#123; method2(0); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println("退出method1方法");&#125; 1.6.2 重写方法异常 父类中未抛出异常 创建一个parent父类 12345678public class Parent &#123; //父类中的测试方法，打印相应语句以便测试 public void test() &#123; System.out.println("parent test"); &#125;&#125; 子类继承没有抛出异常的父类 123456789101112public class Child extends Parent &#123; public void test() throws Exception &#123; System.out.println("child test"); &#125; public static void main(String[] args) &#123; Parent test = new Child(); test.test(); &#125;&#125; 结果：编译不通过。IDE告诉我们“overridden method does not throw ‘java.lang.Exception’”，好尴尬不是么！不过还好，我们吸取了教训，知道了父类未抛出异常时，子类也不能抛出异常的约定，至少没在项目发布上线后才发现问题，万幸万幸。 父类中抛出异常 12345678public class Parent &#123; //和上面类似，只是抛出了一个异常 public void test() throws Exception &#123; System.out.println("parent test"); &#125;&#125; 同样的，再搞一个子类出来，或者也可以将上面的子类稍作修改。如下： 1234567891011public class Child extends Parent &#123; public void test() &#123; System.out.println("child test"); &#125; public static void main(String[] args) &#123; Parent test = new Child(); test.test(); &#125;&#125; 总结：编译…又报错了。main函数中test.test()这一行有问题，必须要抛出一个异常。try..catch一下，再次编译运行，屏幕打印出child test字样。 1234567891011public class Child extends Parent &#123; public void test() &#123; System.out.println("child test"); &#125; public static void main(String[] args) &#123; Child test = new Child(); test.test(); &#125;&#125; 总结：编译通过。引用句柄是不是父类类型时，子类可以不用抛出异常。 如果…我子类不是抛出Exception，而是其子类比如IOException呢？ 12345 public void test() throws IOException &#123; System.out.println("child test"); &#125; 总结：编译通过，main方法里面正常打印出child test 那我把子类和父类的异常掉个包应该也没问题吧： 1234567public class Parent &#123; //父类抛出IOException public void test() throws IOException &#123; System.out.println("parent test"); &#125;&#125; 123456789101112131415public class Child extends Parent &#123; public void test() throws Exception &#123; System.out.println("child test"); &#125; public static void main(String[] args) &#123; Parent test = new Child(); try &#123; test.test(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 总结：竟然又报错了。看来街坊邻居们传的没错，继承体系就是这么“小气”，子类的异常类型必须和父类相同或者是其子类]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自增（++） 与 自减（--）]]></title>
    <url>%2F2017%2F06%2F13%2F20170613%2F</url>
    <content type="text"><![CDATA[你还记得自增（++）和 自减（--）吗？在程序员生涯中，我们在编写代码时，时常会用到 ++ 和 --, 对于这些特殊的运算符的含义和用法，你是否真明白这些运算符的含义? 在编码过程中，我们经常会使用 i=i+1（或则 i=i-1 ）。 i=i+1; // 表示 变量 i+1的值重新赋值给变量 i（也就是 i 自动增加 1 ); i=i-1; // 表示 变量 i-1的值重新赋值给变量 i（也就是 i 自动减 1 ); 在编程语言中存在着一种特殊的运算符， 自增运算符（++） 和 自减运算符（--），这种特殊的运算符则用来表示 变量的 自增 1 或则 自减 1。 例如： i++ 则表示 i=i+1 (也可以把i++ 看做为 i=i+1的简写方式) i-- 则表示 i=i-1 (也可以把i– 看做为 i=i-1的简写方式) 自增（++）: 将变量的值加1，它分为 前缀式（ 如 ++i ）和 后缀式（ 如 i++ ) 自减（--）: 将变量的值减1，它分为 前缀式（ 如 --i ）和 后缀式（ 如 i-- ) 运算符采用 前缀式和后缀式 对本身的影响都是一样的，都是加1或者减1。(也就是说： ++i 和 i++ 都表示 i=i+1) 但是 当把他们作为其他表达式的一部分，两者就有区别了。如：前缀式： j = ++i 表示先运算，再赋值。后缀式： j = i++ 表示先赋值，再运算。 先看一段代码(前缀式)123456789public class Test &#123; public static void main(String[] args) &#123; int i=10; int j=0; j=++i; // 前缀式:表示先运算 则：i=i+1 =&gt; i=10+1 =&gt; i=11, //再赋值:则:j=i =&gt; j=11 System.out.println("j="+j+", i="+i); // 最后结果为 j=11, i=11; &#125; &#125; 再看一段代码(后缀式)123456789public class Test &#123; public static void main(String[] args)&#123; int i=10; int j=0; j=i++; // 后缀式:表示先赋值 则： j=i =&gt; i=10 =&gt; j=10, //再运算：则 i=i+1 =&gt; i=10+1 =&gt; i=11 System.out.println("j="+j+", i="+i); // 最后结果为 j=10, i=11; &#125;&#125; 自减（--）作为 其他表达式的一部分与 自增（++） 一样，这里我就不重复举例了。 再看看下面这段代码12345678public class Test &#123; public static void main(String[] args) &#123; int i=10; int j=(i++)+(++i); int k=(--i)+(i--); System.out.println("i="+i+", j="+j+",k="+k); &#125;&#125; 这段代码运算后 i=?, j=?, k=? 答案为： i=10, j=22, k=22 如果你回答正确了，那说明你对 自增（++）和 自减（--） 运算符 已经算是掌握了。 分析一下上面的代码 i=10； i++ 后缀写法，表示先赋值再运算，也就是 参与运算的值为 10; 然后 i=i+1 此时 i 的值变成为 11 ++i 前缀写法， 表示先运算再赋值，也就是先 i=i+1 此时 i=11+1 侧 i=12 然后在赋值，也就是参与运算的值为 12 j = 10 + 12; 最后 j=22，i=12 --i 前缀写法，表示先运算再赋值 此时先 i=i-1 ，则 i=12-1 =&gt;i=11 此时参与运算的值为 11 i-- 后缀写法，表示先赋值在运算 此时先赋值，则参与运算的值为 11， 再运算 i=i-1=&gt;i=11-1=10 k=11+11 =22; 最后得出答案为：i=10, j=22,k=22; 再问一个问题？下面这段代码能编译通过吗？1234567891011public class Test &#123; public static void main(String[] args) &#123; float f = 1.1f; f++; double d = 2.1d; d++; char c='a'; c++; System.out.println(f+" "+d+" "+c); &#125;&#125; 如果你回答可以，那么你已经掌握了 自增（++） 和 自减（--）运算符了。 答案为： f=2.1 d=3.1 c=b。 自增与自减运算符还遵循以下规律 ： 可以用于整数数据类型byte、short、int、long，浮点类型float、double，以及字符类型 char。 在Java5.0及以上版本中，它们可以用于基本类型对应的包装器类Byte、Short、Integer、Long、Float、Double、Character。 它们的运算结果的类型与被运算的变量的类型相同。 关于面试题来看看面试题的代码:123456789public class Test &#123; public static void main(String[] args) &#123; int j=0; for (int i = 0; i &lt; 100; i++)&#123; j = j++; &#125; System.out.println(j); &#125;&#125;也许你的第一反应和我一样， j=100; 结果答案： j=0 ； 原来这是因为Java编译器使用了中间缓存变量的机制java的编译器在遇到i++和i–的时候会重新为变量运算分配一块内存空间，以存放原始的值，而在完成了赋值运算之后，将这块内存释放掉。 首先看一下如果是 j = i++ 的情况： 所以上图的操作等于如下操作 123temp = i;i=i+1; j=temp; 我们再看看 j = j++ 的情况 所以 最后一次循环后的 j 还是等于 0; 因此对于自增（++）、自减（--）运算符的变量进行赋值时都需要特别注意。 如果在程序中只输入i++就不会出现这个方面的问题，所以大家在以后的程序中如果使用到i=i++的时候要格外小心，一般只需要用 i++ 就不会有问题了。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[switch和if else语句到底用谁]]></title>
    <url>%2F2017%2F06%2F10%2F20170610%2F</url>
    <content type="text"><![CDATA[大家都知道在Java中一共有两种选择语句分别是switch与if语句，但究竟什么时候用？用哪一种好呢？这一直是大家心中的一个小疑虑。 现在简单的回顾switch与if语句的基本构造，再深入了解它们的使用区别。首先回顾下switch与if的基本结构 switch说得再多，不如直接上代码123456switch(choose)&#123; case 1:语句1;break; case 2:语句2;break; case 3:语句3;break; default:默认语句;&#125; 上述是一个简单的switch语句的例子，根据choose的取值不同，选择不同的case语句执行；如果没有匹配任何case值，则执行默认语句。 注意事项：1.choose的数据类型有一定要求：可以为byte、short、char、int、String、枚举，当然不同的JDK版本对switch影响不同。2.choose一般建议是变量，当然也可以是常量。而case后面的值为常量，并且choose与case的值的数据类型要一致。3.还记得每个case语句后的break吗？break表示退出此switch语句，如果没有break，则case语句会继续执行下去。 以上是switch比较重要的知识点，做一个简单的回顾。 接下来回顾下if语句 if语句if语句的样式就比较多了。if语句分为三种：简单if语句、双分支if语句、多分支if语句 简单if语句在代码中展示为：1234if(条件)&#123; 语句1&#125;语句2 大家可以直接从代码中看出来，简单if语句，也就只有if的存在，作为一个简单的判断，不管语句1执不执行，并不妨碍下方语句2的执行。 回顾了简单的if语句，接下来再说说双分支if语句 双分支if语句还记得什么是双分支if语句吗？是在简单if语句的基础上添加对立的条件else语句比如下面的代码：123456if(条件1)&#123; 语句1&#125;else&#123; 语句2&#125;语句3 通过条件1来判断是否需要执行语句1，如果条件1为真，则直接执行语句1；反之为假，则执行语句2。但是不管执行语句1或者语句2，语句3都会执行 双分支if语句中需要时刻了解其else的取值范围。 多分支if语句什么是多分支if语句呢？就是在if…else的基础上，再加入更多的条件进行选择。 12345678if(条件1)&#123; 语句1&#125;else if(条件2)&#123; 语句2&#125;else&#123; 语句3&#125;语句4 由于出现了一个else if，则每个判断的取值发生了变化，但在多分支if语句中，我们虽然可以像下面的代码一样添加更多的else if条件，但是选中的语句只会有一个，也就是说语句1、2、3只会有一个执行，谁先执行后面的就直接无效了，但并不影响语句4的执行。 12345678910if(条件1)&#123; 语句1&#125;else if(条件2)&#123; 语句2&#125;else if(条件3)&#123; 语句3&#125;else&#123; 语句4&#125;语句5 很多同学都已经掌握了上述的内容 接下来，来看一个不一样的if语句 双if语句什么是双if语句呢？1234567if(条件1)&#123;//第一个if语句 语句1&#125;if(条件2)&#123;//第二个if语句 语句2&#125;语句3 这个代码有点奇怪！一个代码中竟然连续出现多个if语句,那问题来了，到底执行哪一个if语句呢？答案是：都可能会执行，每个if语句间没有影响，不管是几个if语句，只要满足条件都会运行。 上述代码，条件1和条件2没有任何的关系，只要条件1满足就执行语句1，只要条件2满足就执行语句2，两者可能都会执行，当然，也可能都不执行；但请注意语句3一定会执行。 注意：不要把双if语句与多分支if语句傻傻分不清楚哟。 接下来进入我们的正题 switch和if else语句到底用谁上面对switch于if else语句进行了基本结构的回顾。 从基本结构也可以看出其区别： switch：主要是将choose中的值和某一个case值进行比较，而case值是一个确定的值。 if else：每个执行的语句前都会有一个条件，这个条件可以是类似x==0的这种匹配一个确定值的布尔表达式，也可以是x&gt;10的这种匹配一个范围的布尔表达式。 从它们的结构可以大致的分析出它们的用法区别，下面我们举几个例子来详细的表现出它们的区别。 例子1：将一个班级按照 0-59：E级 60-69：D级 70—79：C级 80—89：B级 90-100：A级的要求对输入的成绩进行等级评判 若使用if else语句 1234567891011121314151617181920Scanner sc = new Scanner(System.in);int x = sc.nextInt();//前两步骤是在获得输入值if(x&gt;=0&amp;&amp;x&lt;60)&#123;//注意，区间范围之间需要使用&amp;&amp;/||或者&amp;/|，来进行区间划分，而0&lt;=x&lt;60这种写法是禁止的 System.out.println("E级")；&#125;else if(x&gt;=60&amp;&amp;x&lt;69)&#123; System.out.println("D级")；&#125;else if(x&gt;=70&amp;&amp;x&lt;79)&#123; System.out.println("C级")；&#125;else if(x&gt;=80&amp;&amp;x&lt;89)&#123; System.out.println("B级")；&#125;else if(x&gt;=90&amp;&amp;x&lt;=100)&#123; System.out.println("A级")；&#125;else&#123;//当然，不能排除有些同学比较淘气，输入了小于0或者大于100的数据 System.out.println("输入有误")；&#125; 而使用switch来完成该代码呢？ 1234567891011121314151617181920212223Scanner sc = new Scanner(System.in);int x = sc.nextInt();//前两步骤是在获得输入值switch(x/10)&#123;//由于0-100之间有100个数据，用case来一个一个进行划分很麻烦，//所以先让x/10这样的话如:70-79的区间/10，则都为7 case 10://估计有同学会有疑问了，为什么10不做处理却要写出来呢？//原因是100/10等于10，所以有case 10选项，但是由于100和90-99的输出结果是相同的，//不写break，如果是100，则选择case 10，不输出，然后就直接执行case 9的语句，达到效果 case 9:System.out.println("A级")；break; case 8:System.out.println("B级")；break; case 7:System.out.println("C级")；break; case 6:System.out.println("D级")；break; case 5: case 4: case 3: case 2: case 1://上面怎么那么多case语句没有执行的语句呢？//和之间的case 10是一样的，case 5/4/3/2/1/0的效果都是一样的，都需要输出E级，//如果选中0，1,2,3,4,5某一个值，最后都会执行case 0的效果 case 0:System.out.println("E级")；break; default:System.out.println("输入有误")；&#125; 从上面可以看出，if else语句在这道题里用起来感觉挺顺手的，而switch呢？就要复杂得多了。 我们再来看一个例子 例2：给出如下选项，并根据选项进行效果展示：输入1：则输出“普通攻击”；输入2：则输出“魔法攻击”；输入3：则输出“使用道具”；输入3：则输出“逃跑”； 当然，这道题更多出现在游戏的内容中 那如果我们使用if else语句该如何书写呢？ 12345678910111213Scanner sc = new Scanner(System.in);int x = sc.nextInt();//前两步骤是在获得输入值if(x==1)&#123; System.out.println("普通攻击")；&#125;else if(x==2)&#123; System.out.println("魔法攻击")；&#125;else if(x==3)&#123; System.out.println("使用道具")；&#125;else if(x==4)&#123; System.out.println("逃跑")；&#125;else&#123;//当然，依然会有同学比较淘气，不按常理出牌 System.out.println("输入有误")；&#125; 而使用switch语句呢？ 123456789Scanner sc = new Scanner(System.in);int x = sc.nextInt();//前两步骤是在获得输入值switch(x)&#123; case 1:System.out.println("普通攻击")；break; case 2:System.out.println("魔法攻击")；break; case 3:System.out.println("使用道具")；break; case 4:System.out.println("逃跑")；break; default:System.out.println("输入有误")；&#125; 从这个例子可以看出：switch写起来要比if else更为简洁，并且使用x==0这些方式写出来，难免感觉怪怪的。 综上两道题可以看出：switch更适用于有确切值的选择，而if else更适合用于进行范围判断的内容。 当然上述两道题可以互相转换，也就是说到底使用switch还是if else并没有严格要求，在恰当的地方使用恰当的方法是每个程序员需要深思熟虑的。 当然我们的讨论还没有结束，上面只是从例子说明了switch与if else的区别，接下来我们从它们的执行效率上来进行讲解。 switch与if else的执行效率单从JVM的执行效率上讲的话,switch的执行效率要高于if语句： 原因在于:switch语句在运行时，首先会生成一个“跳转表”来指示实际的case分支的地址，而这个“跳转表”的索引号与swtich中的case值是相等的，这样的话，switch就不用像if else那样，遍历所有的条件，直至找到正确条件，而仅仅只需要访问对应索引号的表项就可以到达定位分支的目的。 简单的说，switch会生成一个数据统计表，将case后面的值全部统计起来，匹配时先拿表中的数据进行比较，如果有则直接跳转到相应case语句；如果没有，则直接跳转到default语句。 那if else呢？其实刚刚我们已经简单的说了其工作流程，这里再次说明一下： if else语句需要一条一条的去进行取值范围的判断，直到找到正确的选项位置，这样的话势必会浪费大量的时间。 所以，单从其运行的效率来看，switch语句要更胜一筹。 总结这里简单的总结一下： 1.switch语句由于它独特的case值判断方式，使其执行效率更高，而if else语句呢，则由于判断机制，导致效率稍慢。 2.到底使用哪一个选择语句，和当前的代码环境有关，如果是范围取值，则使用if else语句更为快捷；如果是确定取值，则使用switch更是一个不错的选择。 所有好的程序都是经过不断思考，不断琢磨，付出努力，最终得以完成的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java的安装与环境变量设置]]></title>
    <url>%2F2017%2F06%2F07%2F20170607%2F</url>
    <content type="text"><![CDATA[java的安装与环境变量设置要学习java,至少需要先将java安装到系统中,而且需要配置好必要的环境变量,java才能更好的工作。 下载要安装当然至少需要先下载,你可以直接进入如下网址直接下载最新版本的JDK版本 最新版本的JDK下载地址 进入网页之后,你会看到这样的界面: 直接图中点击箭头指示的JDK,进入如下界面,注意箭筒指示,点击同意下载协议才能开始下载 我们一般都使用的是windows系统,当然下载选择就之后下面的 windows X86与windows X64版本两个 windows X86 对应 windows32位的系统 windows X64 对应 windows64位的系统 这个就需要根据你自己windows的系统进行选择了 现在就可以直接点击下载了…java是免费下载的,不过Oracle公司会在你下载的时候,提示你注册登录,如果你想下载的话…就必须先注册一个Oracle公司的账号…这个无所谓…随便注册一个就可以开始下载了 安装java的安装其实很简单,直接下一步下一步就可以完成,不过需要注意下面两个重要问题: 1.不要安装在带中文路径的目录下面比如类似于: d:\软件 2.最好不要安装在带空格的目录下面比如类似于: c:\Program Files 而且,我们的下载的JDK软件,其实会安装2个东西,一个是JDK,一个是JRE JDK其实就是java development kit,java开发工具包 JRE是java runtime environment,java运行时环境 简单来说,两个东西都是我们必须的,根据中文的意思,我们开发当然使用JDK,如果只是需要运行的话就可以使用JRE,其实这个并不需要纠结,大家都安装好就行了,主要是后面需要配置环境变量的时候需要注意…我们是要用java做开发,所以,一定要配置JDK的路径 如果大家对安装有疑问的话,下面是安装步骤的截图,没有疑问就把这里直接跳过 1.进入安装(注意现在安装的是JDK)注意红框的地方,这里的地址我们最好改变一下…因为默认安装在带空格的Program Files的目录下面 2.点击更改,修改安装目录我这里是直接安装在c盘java目录下 3.JDK安装 4.弹出JRE的安装地址提示注意在安装过程中就会弹出提示框,现在是让你安装JRE了,同样最好改变安装路径地址,而且最好和JDK安装在同一个目录下面 5.最好在JDK同路径下,新建一个JRE安装目录,将JRE安装在该目录下注意我这里是在c盘-&gt;java目录下,新建了一个文件夹,取名为jre1.8.0_131,和之前安装的jdk1.8.0_131在同一路径在最好修改后的路径: 7.进行最后的安装 java的配置首先,我们可以进入jdk的安装目录的bin路径下,你会发现,这里有很多exe可执行文件,现在对我们最重要的是一个java.exe与javac.exe文件我们并不能直接单击他们时候,只能在DOS命令行窗口中,通过键入这两个命令来进行使用 打开DOS命令行窗口在windows7中,在附件中,找到运行在打开的运行窗口中,输入cmd,打开dos命令行 当然,你也可以直接按快捷键 windows标志键 + R 直接打开运行窗口 运行javac命令在打开的DOS命令行中输入JDK,bin目录地址,如下图: 回车,就会进入该目录,在该目录中运行javac命令,如下图:如果出现下面的效果,证明JDK的安装就没有啥大问题了… 但是,现在还存在的一个问题是,只有在C:\Java\jdk1.8.0_131\bin这个目录下,javac命令才会有效果,如果在其他目录,比如C盘根目录,运行javac就不行,如下图: 因此,如果想要javac比较方便在命令行窗口运行,就需要配置环境变量 配置java环境变量进入windows系统界面,点击高级系统设置 点击环境变量 在下面的系统变量中,找到Path选项,点击编辑 在出现的窗口中,输入jdk的bin路径C:\Java\jdk1.8.0_131\bin注意,在路径前一定要加上分号; 一路点击确定,再次重新打开命令行窗口,现在,我们在任意的地址都可以输入javac命令来进行测试了]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[认识计算机硬件]]></title>
    <url>%2F2017%2F06%2F04%2F20170604%2F</url>
    <content type="text"><![CDATA[我要学编程:我叫周大牛，或许你会想到一个卖手链、吊坠什么的一个叫周大福的人，没错，我们仅仅是名字相似而 已。我一直很讨厌被别人联想我和他之间关系的原因在于他永远比不上我的帅气：先做个自我介绍：20岁之前我是一个网管，年纪轻轻就月入2000，掌管整个网吧30台电脑，不管初中还是高中的小孩见我都要叫一声周哥，连吃泡面都要加两个蛋，穿鞋只穿李宁，而且一定要福建产的。曾经我一度是我们村唯一的希望。村花小美从小就崇拜我，整个城乡结合部一致认为小美一定是我的女人，直到21岁生日那天我看到小美上了我头上的那个男人(网吧老板)的车:那一刻开始，我发誓我要出去闯出自已的事业(其实是老板让我滚蛋)。那是我离开家乡的第15天，我依旧来到临时工市场，穿着我帅气的拖鞋，在我的心里默默给自己加油：看了那么多小说，男主落难的时候一定会出现白富美哭着喊着求约。我的白富美，你快出现啊，再不出现我可吃不起晚饭了。 这个时候，那个男子终于出现了，我永远忘记不了这一刻，我的人生就这样被他改变了： 至于原因嘛:他告诉我，通过这本书你可以拥有很多很多对象，用一个换一个。善良的我最后用25块钱买下了这本书，为什么这么便宜，因为书上很多地方都有像血一样的痕迹，他告诉我这是以前买这本书的人激动的喷血，给你这么便宜因为不再接受退货了。就这样，最终我走向了学习程序的道路 我要买电脑:以前我一直是我们乡村结合部的电脑高手，熟悉各种电脑的开关机。但是买电脑还是第一次，总不能去以前的网吧向那个和我有夺妻之恨的人借吧，不行我要买一台属于自己的电脑，免得和以前一样公用电脑，导致我的很多电影被人误删了(我的葫芦娃全集就这样离我而去)。说干就干，明天就去电脑城，今晚回去把家里的牛卖掉换钱，这样就可以完成走向人生巅峰的第一步了。。。 电脑城艳遇:看来老头说的没错，写程序果然会走上人生巅峰，买电脑都能遇到比小美还要漂亮的，莫非她就是上天给我的安排？看来这条路选对了，暗暗为自己点个赞。拿出我500块钱买的苹果6，换了块电池(外国手机就是费电)，赶紧偷偷拍一张： 整理了一下我那件才穿几十次的条纹衬衣，用最霸道方式走向了她，在她惊讶的注释下，我无比优越的说：给我买台电脑，私人电脑，如果你想要我的电话也行。我偷偷看了下她胸口的吊牌，上边写着她的名字:苍小优。 小苍老师带你学:苍小优：好的帅哥(看看，果然大城市的美女才能品味出我独特的帅气)，请问你是买品牌机还是自己DIY呢？ 周大牛：。。。D啥Y，这是个什么东西，你能不能解释一下。 苍小优：DIY是英文Do It Yourself的缩写，可以正式译为自己动手做，一般对电脑熟悉的人都是自己购买电脑的硬件然后组装在一起，当然这可能存在电脑硬件兼容性问题，不过一般只要你告诉销售人员你电脑其他硬件，他们会帮你参考解决兼容性问题。当然如果你不了解电脑的话也可以购买整体电脑，就是我们说的品牌机。 周大牛：我可是要成为程序员的男人，必须D个Y，不过小姐姐你可不可以给我仔细讲解下我需要购买哪些硬件呢，玩游戏我在行，可是电脑的这些东西我是都不认识。 苍小优：没问题程序员先生，那我现在就给你讲讲计算机硬件的组成，首先我们我们必须认识CPU，这个可是计算机最核心的东西: 中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。 再通俗的说呢：CPU就是电脑的中央处理器,就好比人的心脏.你的计算机要做什么事情都是由它去发布命令。所以呢，这也是购买电脑的时候的一个主要开销了。目前CPU最大的两个品牌分别是Intel和AMD，等下你可以在它们之间根据喜好购买 接着呢我们来认识下一个非常厉害的东东：内存 内存(Memory)是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大计算机运行程序的时候，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来，内存的运行也决定了计算机的稳定运行 目前市场上流行的计算机内存的生产厂商有金士顿、现代、三星、威刚等。当然如果你平时如果对电脑反应速度快点的话可以购买一些比较大的内存，目前比较多的选择是8G、16G，当然如果有需要可以购买多个内存条让你电脑运行更快，而且内存的价格没有CPU那么贵哦。 接着我们再看电脑下一个必需品：硬盘 硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料，平时你存放在电脑上的资料其实都在这里边，注意：CPU和内存都是运行软件的地方，真正存储资料的地方在硬盘中 硬盘呢有很多种类，主要有这几种：固态硬盘（SSD）、机械硬盘（HDD ）、混合硬盘（HHD 一块基于传统机械硬盘诞生出来的新硬盘）； 其中ssd里面是由闪存颗粒组成的 读取速度要比HDD快的多 但是使用寿命的话ssd没有hdd这么久 他的读取次数是有限的 还有就是目前ssd价格较高 目前来看还是用HDD比较划算。 这个呢，就是大名鼎鼎的主板，刚才我们所说的CPU,内存，硬盘什么的为了统一管理，我们把它们全部安装到主板上，这样它们之间就能共同合作，完成你所要完成的所有事情了 主板（英语：Motherboard,Mainboard，简称Mobo）供处理器、显卡、声效卡、硬盘、存储器、对外设备等设备接合 目前比较流行的主板的品牌有：华硕（ASUS） 技嘉（GIGABYTE） 微星（MSI）等，主板的价格也稍微贵一点，同样也是你购买计算机的时候主要的开销之一 当然咯，主板上这么多插口到底做什么用的呢，除了方才我们所说的这些必需品(cpu、内存、硬盘)之外，如果你对电脑音质和画质有高品质要求，你可以购买单独的声卡和显卡(如果打游戏必备)。 声卡 (Sound Card)也叫音频卡（港台称之为声效卡），是多媒体技术中最基本的组成部分，是实现声波/数字信号相互转换的一种硬件。声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口(MIDI)使乐器发出美妙的声音 显示接口卡（Video card，Graphics card），又称为显示适配器（Video adapter）显卡的用途是将计算机系统所需要的显示信息进行转换驱动显示器，并向显示器提供行扫描信号，控制显示器的正确显示，是连接显示器和个人电脑主板的重要元件，是“人机对话”的重要设备之一。 当然如果不购买也没关系，主板上有集成的声卡和显卡，当然效果就没那么好了 接下来，我们刚才列举的这些计算机必备品，我们需要找个东西把它们集中管理装起来，那就是我们的主机箱咯： 机箱作为电脑配件中的一部分，它起的主要作用是放置和固定各电脑配件，起到一个承托和保护作用，此外，电脑机箱具有电磁辐射的屏蔽的重要作用，由于机箱不像CPU、显卡、主板等配件能迅速提高整机性能，所以在DIY中一直不被列为重点考虑对象。 我们将刚才的硬件全部按照说明安装到主机箱里边就可以正常工作了。主机箱的价格比较便宜。所以选择一个你喜欢样子的主机箱吧。 当然要启动你的电脑还需要一个必须用品，那就是电源： 电脑电源是把220V交流电，转换成直流电，并专门为电脑配件如CPU、主板、硬盘、内存条、显卡、光盘驱动器等供电的设备，是电脑各部件供电的枢纽，是电脑的重要组成部分。目前PC电源大都是开关型电源。 同样的电源价格也不是很贵，但我们需要选择一个比较大的品牌，质量过关的电源才可以，目前市场上大品牌主要有 航嘉 | 鑫谷 | aigo | 金河田 | 先马 | 长城机电 | Tt | 安钛克 等 这样一台电脑基本上核心部分就完成了，剩下的就不需要太多解释了，每个使用电脑的人都知道还有这些需要配置的： 显示器 显示器有贵的有便宜的，价格相差比较大，你可以选择普通偏上的1000-1500左右的就可以了，目前主流品牌有：AOCSamsung/三星飞利浦Benq/明基Dell/戴尔HKC/惠科等 鼠标、键盘 顺手的鼠标键盘能让你事半功倍，当然也不需要苛求太好了，价格也不是很贵，几百块钱之内就能买到很好的键盘鼠标了 有了这些东西，一台计算机就算配完了，当然了，音箱什么的你可以以后慢慢自己配置了 现在我就带你去购买这些东西吧。。。 又一名程序员:最终我花了5000块钱购买了电脑，并且顺利约小优导购一起吃了闻名中外的开封菜，并且得到了她的QQ号码。从明天起，我就要成为程序员的男人了，努力啊，奋斗啊！！]]></content>
      <categories>
        <category>计算机常识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为什么老鸟要告诉你优先使用组合而不是继承？]]></title>
    <url>%2F2017%2F06%2F01%2F20170601%2F</url>
    <content type="text"><![CDATA[大家知道，面向对象有三个特征：继承、封装和多态。现在，我们谈谈关于继承的一些问题。了解一下继承的优点、缺点，以及继承缺点的解决方案。 继承的起源，来自于多个类中相同特征和行为的抽象。子类可以通过继承父类，那么可以调用父类中定义的方法和属性，从而达到代码重用的目的。另外，子类除了重用父类的代码以外，还可以扩展自身的属性和方法，来描述子类特有的特征和行为。 例如：人类和马类这两个类，有什么共同的特征和行为呢？都有年龄，都要呼吸，都可以行动，都要吃奶。我们可以把人类和马类相同的特征和行为抽取出来，形成一个父类：哺乳动物。人类和马类只要继承哺乳动物这个父类。那么，就可以直接重用哺乳动物父类中定义的属性和行为，相同的属性和行为就可以不用再重复描述。所以，通过继承，可以达到代码很大的重用。 除此之外，人类和马类还可以再定义自己本身的特征和行为。比如，马要吃草，人可以说话。那么，人类和马类可以在继承了哺乳动物父类的同时，再定义说话或吃草的行为，来扩展自身的特征和行为。 123456789101112131415161718class Mammal&#123; private int age; public void breath()&#123;&#125;&#125;class ManKind extends Mammal &#123; public void speak()&#123;&#125;&#125;……ManKind m = new ManKind();m.spaeak();//本类中定义的方法m.breath();//父类中继承的方法 使用继承有很多优点，父类的大部分功能可以通过继承关系自动进入子类；修改或扩展继承而来的属性和方法较为容易。那么，如何判断两个类之间是否有继承关系呢？很简单，用”是”来判断。比如：马是动物。那么马继承于动物。玫瑰是植物。那么玫瑰继承于植物。骂人的时候，我们会说：你是畜牲，那么这个人继承于畜牲，象畜牲一样没有人性。你是猪，那么这个人继承于猪，象猪一样愚笨。这就是所谓的”is-a”。 但是，继承同样有很多缺点。人类在大千世界中，不断的认识世界，也不断的改造世界。人类曾经梦想，在天空中飞翔。那么，人类如何飞行呢？鸟可以飞行，那是因为鸟有翅膀这个特征，才会拥有飞这个行为。如果人类继承于鸟类，象鸟一样长出翅膀，那么也就可以有飞行的行为了。 《封神榜》中的雷震子和天使，其实就是人类想在天空中飞行的一种想法。那就是继承鸟这个类，拥有鸟类的翅膀和飞行的行为。 那么，人类想下海应该怎么办呢？于是人类又在想，只要将人类继承于鱼类，拥有鱼的尾巴，那么就可以下海了。随着这种想法的产生，美人鱼就出现了。 那么，如果人类既想飞行，又想下海应该怎么办呢？有人说，那还不简单，把人类同时继承于鸟类和鱼类不就行了吗。但是，不好意思，在java中，类只能单根继承。也就是说，一个类只能有一个父类，不能同时继承两个父类。所以，从这里就可以看出继承的其中一个缺点：无法通过继承的方式，重用多个类中的代码。 除此之外，继承还有第二个缺点，那就是，父类的属性和方法，子类是无条件继承的。也就是说，不管子类愿意不愿意，都必须继承父类所有的属性和方法。比如，每个人都有自己父母，如果父母比较富有，那么子女就吃得好穿得好。如果父母是穷人，那么子女吃不饱穿不暖。很显然，所有的人都希望自己是富二代，官二代，而不想成为穷二代。不过，人是无法选择自己父母的。所以，父母的一切，自己是无条件接受的。 同样道理，如果人类继承于鸟类，我们希望拥有的是：鸟的翅膀和飞的行为。但是，鸟还有吃虫的行为，鸟还有下蛋的行为。这些是我们不希望拥有的。不过，如果人类继承于鸟类的话，那么吃虫和下蛋的行为，人类就得无条件接受了。所以，使用继承很容易造成方法的污染。一旦父类的属性和方法，在子类中不能完全适用。那么，也就不应该使用继承关系了。 1234567891011121314class Bird&#123; public void fly()&#123;&#125; public void layEggs()&#123;&#125;&#125;class ManKind extends Bird&#123; public void speak()&#123;&#125;&#125;……ManKind m = new ManKind();m.spaeak();m.fly();//人类希望拥有的飞行行为m.layEggs();//人类不希望拥有的下蛋行为 还有，从父类继承而来的实现是静态的，不能在运行时发生改变，不够灵活。比如，有一个人从春熙路到天府广场去。 123456789101112class Man&#123; public void run()&#123; System.out.println("前往天府广场"); &#125;&#125;class CDMan extends Man&#123;&#125;……CDMan c = new CDMan();c.run(); 当我们调用run()方法时，就只能打印从父类中继承的run方法。如果这个人想骑单车去天府广场应该怎么办呢？有人说，简单，在CDMan中重写run()不就行了吗？ 123456class CDMan extends Man&#123; @Override public void run()&#123; System.out.println("骑单车去天府广场"); &#125;&#125; 但是，如果这个人想骑单车走一段，再开汽车走一段，就没法通过继承和重写来实现了。所以，无论是从父类中继承的方法，还是子类重写的父类方法，实现的都是一种静态的复用。不能在运行时发生改变，灵活性比较差。 那么，如何解决继承的这些缺点呢？荀子在《劝学》中，有这样的一段话：”假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。”就是说，人可以骑马，即使这个人跑得不快，也可以到达千里之外。人可以坐船，即使这个人不会游泳，也可以到达江河的任何位置。君子其实没什么太多特别的地方，只不过善于利用工具而已。这就是所谓的”has-a”。拥有什么，或者使用什么。 荀子的这段话，指出了解决继承缺陷办法，那就是使用聚合/组合达到代码的复用。比如，人想上天怎么办呢？可以利用飞机上天。人想下海怎么办呢，可以利用轮船下海。并不要求人要长出翅膀，人要长出鱼尾。 这样的解决方案，其实就是告诉我们，与其我们”是什么”，倒不如我们”用什么”。也就是用聚合/组合复用，去代替继承复用。把一些特征和行为抽取出来，形成工具类。然后通过聚合/组合成为当前类的属性。再调用其中的属性和行为达到代码重用的目的。 换句话说，用”has-a”(有什么或用什么)去替代”is-a”(是什么)。 12345678910111213141516class Plane&#123; public void fly()&#123;&#125;&#125;class Ship&#123; public void swim()&#123;&#125;&#125;class ManKind &#123; private Plane p = new Plane(); private Ship s = new Ship(); public void fly()&#123; p.fly(); &#125; public void swim()&#123; s.swim(); &#125;&#125; 从以上代码可以看出，通过聚合/组合关系，可以解决继承的缺点。由于一个类可以建多个属性，也就是可以聚合多个类。所以，可以通过聚合/组合关系，重用多个类中的代码。 另外，我们可以选择一个类中是否应该具有某种行为，从而决定应该聚合那些类，不应该聚合那些类。这样，通过聚合/组合关系，也可以避免继承所带的方法污染问题。所以，使用聚合/组合，具有很强的代码重用性和灵活性。 聚合/组合复用也可以在运行时动态进行。新对象可以使用聚合/组合关系，将新的责任委派到合适的对象。 123456789101112131415161718192021222324252627282930313233343536//交通工具接口interface Vehicle&#123; public void run();&#125;//自行车实现类class Bike implements Vehicle&#123; public void run()&#123; System.out.println("骑单车行走"); &#125;&#125;//汽车实现类class Car implements Vehicle&#123; public void run()&#123; System.out.println("开汽车行走"); &#125;&#125;//人类class CDMan &#123; private Vehicle v; public void run()&#123; v.run(); &#125;//更换交通工具 public void changeVehicle(Vehicle v)&#123; this.v = v; &#125; &#125;……CDMan c = new CDMan();c.changeVehicle(new Bike());c.run();//骑单车行走c.changeVehicle(new Car());c.run();//开汽车行走 从这里可以看出，人类可以随时改换交通工具，达到行走的目的。这种方式可以在运行期间，随时改变接口属性的实现类。从而调用不同实现类描述的具体方法，灵活性很强。 总结： 继承和聚合/组合都可以达到代码重用的目的。继承有自身的优点，父类的大部分功能可以通过继承关系自动进入子类；修改或扩展继承而来的实现较为容易。 但是，继承同样有缺点， 无法通过继承达到多个类代码的重用。 父类的方法子类无条件继承，很容易造成方法污染。 从父类中继承的方法，是一种静态的复用。不能在运行时发生改变，不够灵活。 继承可以用，但使用继承需要谨慎。一般来说，使用继承有两个条件： 父类中所有的属性和方法，在子类中都适用。 子类不需要再去重用别的类中的代码。如果不能满足这两个条件，那么就应该使用聚合/组合关系去替代继承，来达到代码的复用。]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[别被final、finally和finalize这三兄弟给骗了，其实它们半毛钱关系也没有]]></title>
    <url>%2F2017%2F05%2F27%2F20170527%2F</url>
    <content type="text"><![CDATA[Java的这三个兄弟final、finally和finalize，你别说，他们三个看起来还真像，不把眼睛睁大点还真分辨不出来。难怪在Java面试时，面试官就喜欢拿来糊弄我们这些Java菜鸟。 最近小马云在网上火了，马云凭空多出来一个儿子，也真够衰的，哈哈。我还真百度搜了一下马云的真儿子，叫马元坤；估计比较低调，不像王思聪深怕没人知道他老爸就是王健林。这娃一看就是一枚小鲜肉，还好长得一点都不像他老爸，不然肯定会误认为是“孙悟空转世”。 还是回过头来，看一下我们Java的这三个假兄弟final、finally和finalize。你别说，他们三个看起来还真像，不把眼睛睁大点还真分辨不出来。难怪在Java面试时，面试官就喜欢拿来糊弄我们这些Java菜鸟。 你老说它们半毛钱关系也没有，那么他们究竟是哪里来的？别着急！我们马上就让这三兄弟各回各家，各找各妈。 finalfinal从字面上理解含义为“最后的，最终的”。在Java中也同样表示出此种含义。 final可以用来修饰变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类。 final修饰类 final修饰类即表示此类已经是“最后的、最终的”含义。因此，用final修饰的类不能被继承，即不能拥有自己的子类，俗称“太监类”。如果试图对一个已经用final修饰的类进行继承，在编译期间就会发生错误。 123final class User &#123; //被final修饰的类不能被继承 …&#125;那有哪些类是太监类呀？String就是一个被final修饰的类，我们只能用，不能继承。 2. final修饰方法 final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即此方法不能被重写（可以重载多个final修饰的方法）。 此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。1234567891011121314151617181920public class B extends A &#123; public static void main(String[] args) &#123; &#125; public void getName() &#123; &#125;&#125; class A &#123; //因为private修饰，子类中不能继承到此方法。 //因此，子类中的getName方法是重新定义的、 属于子类本身的方法 private final void getName() &#123; //编译正常 &#125; //因为public修饰，子类可以继承到此方法，导致重写了父类的final方法 public final void getName() &#123; //编译出错 &#125;&#125; 3. final修饰变量 final修饰的变量表示此变量是“最后的、最终的”含义。一旦定义了final变量并在首次为其显示初始化后，final修饰的变量值不可被改变。 final修饰的实例变量 被final修饰的实例变量必须显示指定初始值，而且只能在如下3个位置指定初始值： 1.定义final实例变量时指定初始值； 2.在非静态初始化块中为final实例变量指定初始值 3.在构造器中为final实例变量指定初始值 对于普通实例变量，Java程序可以对它执行默认的初始化，也就是将实力变量的值指定为默认的初始值0或null，但对于final实例变量，则必须由程序员显示指定初始值。 final实例变量必须显示地被赋初始值，而且本质上final实例变量只能在构造器中被赋初始值。在定义final实例变量时指定初始值，和在初始化块中为final实例变量指定初始值本质上是一样的。除此之外，final实例变量将不能被再次赋值。 final修饰的类变量 对于final类变量而言，同样必须显示指定初始值，而且final类变量只能在2个地方指定初始值： 1.定义final类变量时指定初始值； 2.在静态初始化块中为final类变量指定初始值； 这两种方式都会被抽取到静态初始化块中赋初始值。定义final类变量时指定初始值和在静态初始化块中为final类变量指定初始值，本质是一样的。除此之外final类变量将不能被再次赋值。 final修饰局部变量 final修饰的局部变量一样需要被显式地赋初始值，因为Java本来就要求局部变量必须被显式地赋初始值。与普通变量不同的是，final修饰的局部变量被赋初始值之后，将不能再被重新赋值。 final修饰符的第一简单的功能就是一旦被赋初始值，将不可改变。final的另一个简单的功能就是在定义了该final类变量时指定了初始值，且该初始值可以在编译时就被确定下来，系统将不会在静态初始化块中对该类变量赋初始值，而将是在类定义中直接使用该初始化值代替该final变量。 对于一个使用final修饰的变量而言，如果定义该final变量时就指定初始值，而且这个初始值可以在编译时就确定下来，那么这个final变量将不再是一个变量，系统会将其变成“宏变量”处理。所有出现该变量的地方，系统将直接把它当成对应的值处理。 执行“宏替换”的变量 对于一个final变量，不管它是类变量、实例变量还是局部变量，定义了该变量时使用了final修饰符修饰，并在定义该final类变量时指定了初始值，而且该初始值可以在编译时就被确定下来，那么这个final变量本质上已经不再是变量，而是想当于一个直接的变量。 final修饰符的一个重要用途就是定义“宏变量“，当定义final变量时就为该变量指定了初始值，而且该初始值可以在编译的时候就确定下来，那么这个final变量本质上就是一个”宏变量“，编译器会把程序中所用到该变量的地方直接替换成该变量的值。如果被赋的表达式只是基本的算术运算表达式或字符串连接运算，没有访问普通变量，调用方法，Java编译器同样会将这种final变量当成”宏变量“处理。 对于实例变量而言，可以在定义该变量时赋初始值之外，还可以在非静态初始化块、构造器中对它赋初始值，在这三个地方指定初始值的效果基本一样。但对于final实例变量而言，只有在定义该变量时指定初始值才会有”宏变量“的效果，在非静态初始化块、构造器中为final实例变量指定初始值则不会有这种效果。对于普通类变量而言，在定义时指定初始值，在静态初始化块中赋初始值的效果基本一样。但对于final类变量而言，只有在定义final类变量时指定初始值，系统才会对该final类变量执行”宏替换“ 内部类中的局部变量 不仅匿名内部类，即使是普通内部类，在任何内部类中访问的局部变量都应该使用final修饰。 此处说的内部类指的是局部内部类，只有局部内部类（包括匿名内部类）才可以访问局部变量，普通静态内部类、非静态内部类不可能访问方法体内的局部变量。Java要求所有被内部类访问的局部变量都使用final修饰，对于普通局部变量而言，它的作用域就是停留在该方法内，当方法执行结束，该局部变量也随之消失。但内部类则可能产生隐式的”闭包“闭包将使得局部变量脱离它所在的方法继续存在。 匿名内部类的实例生命周期没有结束的话，将一直可以访问局部变量的值，这就是内部类会扩大局部变量作用域的实例。由于内部类可能扩大局部变量的作用域，如果再加上这个被内部类访问的局部变量没有使用final修饰，也就是说该变量的值可以随意改变，就会引起大乱。因此Java编译器要求所有被内部类访问的局部变量必须使用final修饰。 finally finally从字面上理解含义为“最后的；决定性地；最终的”。在Java中的finally关键字一般与try/catch一起使用，如下图： 在程序进入try块之后，无论程序是因为异常而中止或其它方式返回终止的，finally块的内容一定会被执行，还是写个例子来说明下1234567891011121314151617181920212223242526272829303132public class TryAndFinallyTest &#123; public static void main(String[] args) throws Exception&#123; try&#123; int a = testFinally(2); System.out.println("异常返回的结果a:"+a); &#125;catch(Exception e)&#123; int b = testFinally(1); System.out.println("正常返回的结果b:"+b); &#125; int b = testFinally(3); System.out.println("break返回的结果:"+b); b = testFinally(4); System.out.println("return返回的结果:"+b); &#125; static int testFinally(int i) throws Exception&#123; int flag = i; try&#123; //一旦进去try范围无论程序是抛出异常或其它中断情况， //finally的内容都会被执行 switch(i)&#123; case 1:++i;break;//程序 正常结束 case 2:throw new Exception("测试下异常情况"); case 3:break; default :return -1; &#125; &#125;finally&#123; System.out.println("finally coming when i="+flag); &#125; return i; &#125;&#125; 执行结果如下: finally coming when i=2 finally coming when i=1 正常返回的结果b:2 finally coming when i=3 break返回的结果:3 finally coming when i=4 return返回的结果:-1 结果说明无论上述什么情况，finally块总会被执行。 与其他语言的模型相比，finally 关键字是对 Java 异常处理模型的最佳补充。finally 结构使代码总会执行，而不管有无异常发生。使用 finally 可以维护对象的内部状态，并可以清理非内存资源。 如果没有 finally，您的代码就会很费解。 例如，下面的代码说明，在不使用 finally 的情况下您必须如何编写代码来释放非内存资源：123456789101112131415161718import java.net.*; import java.io.*;public class WithoutFinally &#123; public void foo() throws IOException &#123; //在任一个空闲的端口上创建一个套接字 ServerSocket ss = new ServerSocket(0); try &#123; Socket socket = ss.accept(); //此处的其他代码... &#125;catch (IOException e) &#123; ss.close(); //1 throw e; &#125; //... ss.close();//2 &#125;&#125; 这段代码创建了一个套接字，并调用 accept 方法。在退出该方法之前，您必须关闭此套接字，以避免资源漏洞。为了完成这一任务，我们在 //2 处调用 close，它是该方法的最后一条语句。 但是，如果 try 块中发生一个异常会怎么样呢？在这种情况下，//2 处的 close 调用永远不会发生。因此，您必须捕获这个异常，并在重新发出这个异常之前在 //1 处插入对 close 的另一个调用。这样就可以确保在退出该方法之前关闭套接字。 这样编写代码既麻烦又易于出错，但在没有 finally 的情况下这是必不可少的。不幸的是，在没有 finally 机制的语言中，程序员就可能忘记以这种方式组织他们的代码，从而导致资源漏洞。Java 中的 finally 子句解决了这个问题。有了 finally，前面的代码就可以重写为以下的形式：1234567891011121314import java.net.*;import java.io.*;public class WithoutFinally &#123; public void foo() throws IOException &#123; //在任一个空闲的端口上创建一个套接字 ServerSocket ss = new ServerSocket(0); try &#123; Socket socket = ss.accept(); //此处的其他代码... &#125; finally &#123; ss.close(); &#125; &#125;&#125; finally 块确保 close 方法总被执行，而不管 try 块内是否发出异常。因此，可以确保在退出该方法之前总会调用 close 方法。这样您就可以确信套接字被关闭并且您没有泄漏资源。 在此方法中不需要再有一个 catch 块。在第一个示例中提供 catch 块只是为了关闭套接字，现在这是通过 finally 关闭的。如果您确实提供了一个 catch 块，则 finally 块中的代码在 catch 块完成以后执行。 finally 块必须与 try 或 try/catch 块配合使用。此外，不可能退出 try 块而不执行其 finally 块。如果 finally 块存在，则它总会执行。 那有没有办法退出try而不执行finally块？答案是：有 如果代码在 try 内部执行一条 System.exit(0); 语句，则应用程序终止而不会执行 finally 执行。 如果您在 try 块执行期间快速拨掉电源，finally 也不会执行。 finalize finalize从字面上理解含义为“完成; 使结束; 使落实;”。Java的垃圾回收器要回收对象的时候，首先要调用这个类的finalize方法。 一般的纯Java编写的Class不需要重新覆盖这个方法，因为Object已经实现了一个默认的，除非我们要实现特殊的功能(这 里面涉及到很多东西，比如对象空间树等内容)。 不过用Java以外的代码编写的Class(比如JNI，C++的new方法分配的内存)，垃圾回收器并不能对这些部分进行正确的回收，这时就需要我们覆盖默认的方法来实现对这部分内存的正确释放和回收(比如C++需要delete)。 总之，finalize相当于析构函数，它是垃圾回收器回收一个对象的时候第一个要调用的方法。不过由于Java的垃圾回收机制能自动为我们做这些事情，所以我们在一般情况下是不需要自己来手工释放的。 有时当撤消一个对象时，需要完成一些操作。例如，如果一个对象正在处理的是非Java 资源，如文件句柄或window 字符字体，这时你要确认在一个对象被撤消以前要保证这些资源被释放。为处理这样的状况，Java 提供了被称为收尾（finalization ）的机制。使用该机制你可以定义一些特殊的操作，这些操作在一个对象将要被垃圾回收程序释放时执行。 要给一个类增加收尾（finalizer ），你只要定义finalize ( ) 方法即可。Java 回收该类的一个对象时，就会调用这个方法。在finalize ( )方法中，你要指定在一个对象被撤消前必须执行的操作。垃圾回收周期性地运行，检查对象不再被运行状态引用或间接地通过其他对象引用。就在对象被释放之 前，Java 运行系统调用该对象的finalize( ) 方法。 12345//finalize()方法的通用格式如下protected void finalize( ) &#123; // finalization code here&#125; 其中，关键字protected是防止在该类之外定义的代码访问finalize()标识符。 理解finalize( ) 正好在垃圾回收以前被调用非常重要。例如当一个对象超出了它的作用域时，finalize( ) 并不被调用。这意味着你不可能知道何时——甚至是否——finalize( ) 被调用。因此，你的程序应该提供其他的方法来释放由对象使用的系统资源，而不能依靠finalize( ) 来完成程序的正常操作。 注意：如果你熟悉C++，那你知道C++允许你为一个类定义一个撤消函数（destructor ），它在对象正好出作用域之前被调用。Java不支持这个想法也不提供撤消函数。finalize() 方法只和撤消函数的功能接近。当你对Java 有丰富经验时，你将看到因为Java使用垃圾回收子系统，几乎没有必要使用撤消函数。 finalize的工作原理是这样的： 一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存.所以如果使用finalize()，就可以在垃圾收集期间进行一些重要的清除或清扫工作. finalize()在什么时候被调用?有以下三种情况： 1.所有对象被Garbage Collection（垃圾回收器）时自动调用,比如运行System.gc()的时候. 2.程序退出时为每个对象调用一次finalize方法。 3.显式的调用finalize方法 除此以外,正常情况下,当某个对象被系统收集为无用信息的时候,finalize()将被自动调用,但是jvm不保证finalize()一定被调用,也就是说,finalize()的调用是不确定的,这也就是为什么sun公司并不提倡使用finalize()的原因。 总算把final、finally和finalize介绍完了，渴死了，先喝口水。大家现在应该不会被他们骗到了吧。其他它们是不会骗人的，只是被人利用了，是谁呀，还有谁，Java门神-面试官。]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA中常见的排序算法有哪些？---冒泡排序]]></title>
    <url>%2F2017%2F05%2F24%2F20170524%2F</url>
    <content type="text"><![CDATA[排序相关的的基本概念 排序： 将一组杂乱无章的数据按一定的规律顺次排列起来。数据表( data list): 它是待排序数据对象的有限集合。排序码(key):通常数据对象有多个属性域，即多个数据成员组成,其中有一个属性域可用来区分对象,作为排序依据。该域即为排序码。每个数据表用哪个属性域作为排序码，要视具体的应用需要而定。 我们常见的一些排序算法，如图所示： 交换排序交换排序的基本思想是：两两比较待排序记录（数据表）的关键字（排序码），发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。主要包括冒泡排序和快速排序。 现在，我们先一起来看看交换排序 之 冒泡排序 冒泡排序的原理 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 一听到冒泡这个词，大家可能会想到？对，没错，我们可以把冒泡排序看成生活中冒气泡的方式，从下往上冒，依次把最大或最小的值冒到最顶层。例如:有一个整型数组int[] nums = {84,83,88,87,61};其排序后的结果，如图：接下来，我们更进一步来分析它的比较过程： 冒泡排序的代码实现 i ： 控制第几轮，如果5个数，最多就比较4轮，所以i的索引从0开始的话，要循环4次，就应该是长度-1 j： 控制每一轮中的元素下标位置，每结束一轮，就会出来一个当前这轮中的最大值，则减i,之所以再减1，是因为最后剩一个元素的时候没有相邻的数与其分组，所以不用再比较了 12345678910for(int i = 0 ;i&lt;nums.length-1;i++)&#123; for(int j = 0;j&lt;nums.length-i-1)&#123; if( nums[j] &gt; nums[j+1])&#123; //相邻的两个元素比较 int temp;//借用第三个变量来达到两个元素的交换，如同交换两瓶水，需要第三个空瓶子 temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; &#125; &#125;&#125; 以上则是交换排序之冒泡排序的算法原理和具体实现步骤，敬请期待java中的其他排序算法]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[有GC就是爽，再也不用自己清理垃圾了]]></title>
    <url>%2F2017%2F05%2F21%2F20170521%2F</url>
    <content type="text"><![CDATA[Java中的“GC”是什么呢？它的英文是Garbage Collection，翻译过来就是垃圾回收，是JVM用来帮你回收Java程序中产生的垃圾的一种机制。对于Java工程师(码农)来说，了解垃圾回收机制（GC）有哪些好处呢？首先，可以装逼，哦，不不，可以满足Java工程师(码农)求知欲；其次，可以帮你写出更好的Java应用程序。 想了解GC，你得先了解它们：首先，来看JVM在运行时的内存图：这里呢，咱们只说说堆内存和栈内存堆内存：Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。你也可以这么理解，(敲黑板，往下划重点了)它是管理对象的，凡是new出来的对象，都在堆内存里。这块内存呢，是可以调配大小的，这里有参数：-Xms:设置JVM启动时最小的堆内存大小-Xmx:设置JVM堆的最大内存大小栈内存：(敲黑板，往下划重点了)一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。通过这个参数可以调配它的大小，-Xss：这个参数就是用来指定栈的大小这里咱们举个例子再来说明堆和栈，假如有这样两句话：int i=10;LovoStudent s = new LovoStudent();它们在JVM的内存中如何分配呢？看图：为何让大家看内存图呢？是为了说明什么是Java中的垃圾。那这个垃圾到底是什么呢？你可以这么理解，(敲黑板，往下划重点了)凡是不被引用变量引用的对象都是垃圾。哦豁，什么意思，自己去揣摩10分钟。揣摩完回来，咱们拿上面的例子来说，还是这句话，LovoStudent s = new LovoStudent(); 我把这个堆内存中的new LovoStudent();变成垃圾怎么来写？直接写 s=null;引用变量不再引用堆内存的对象，那这个对象就是垃圾。那么我问个智障问题，咱们所说的垃圾，会存在于JVM中哪块内存里？ 垃圾回收明白了以上的内容，垃圾回收原理就很容易理解了。垃圾回收机制就是JVM根据一定的算法和线程调度(这里只做简单认识，感兴趣的关注朗沃博客，后续有文章会详解哪些算法和线程调度)来处理产生的垃圾。这种机制对程序员来说，比10个G的高清无码岛国动作片都来的爽，因为你不用手动释放内存了，也不用担心内存泄漏问题。在其它语言中，比如C，手动释放内存很蛋疼呐！说到回收，不得不提Object类中的finalize()方法，当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。也就是说当一个对象被当作垃圾回收时，会调用该方法。既然如此，那咱们是不是可以写个类继承一下Object(废话，你能写个类不继承自Object么)，覆写finalize()，比如写个输出语句：System.out.println(“我成垃圾了，正在被回收”);来显式的看一看对象什么时候被回收的呢？完全可以。说完这个finalize()方法，还得说说System.gc()方法，这个方法又是干嘛的？运行垃圾回收器。调用 gc 方法意味着JVM做了一些努力(注意是一些努力，并不是100%，通常还是能回收的)来回收未用对象，以便能够快速地重用这些对象当前占用的内存。说完这些前提，咱们就可以设个场景，假如你去饭馆吃饭，首先得占个桌子，占了桌子之后呢就点菜上菜，假设你是土豪，可以点很多菜，陆续上来，先上的菜一来，你一顿的胡吃海塞留下很多垃圾，后来的菜再来，可能没地方放。开饭馆的肯定考虑这个问题啊，毕竟顾客是上帝嘛，于是安排了个服务员小妹儿，不定时的在场子里巡回，来收走你吃完菜的盘子。好像这问题就解决了，但是，不排除你是个吃货，吃的太快了，小妹儿来不及巡回到你这儿，你就有很多垃圾了，此时你是不是得大喊一声，“哎，小妹儿，到这儿收空盘子”，然后小妹儿对你微微一笑，“好的，我马上来收”(当然小妹儿也可能会说“哎呀，客官稍等，马上就来”)。至于在收盘子时候你们再发生点啥，那就得看自个了⋯⋯（嘿嘿嘿⋯⋯）好，打住，不是说好的讲GC的嘛，怎么扯到饭馆小妹儿了，咳咳⋯⋯是这样子，饭馆——JVM桌子——堆内存菜——对象空盘子等垃圾——未被引用的对象小妹儿不定时巡回收垃圾——JVM的一定算法和线程调度回收垃圾你喊小妹儿收盘子——调用System.gc()方法好了，只能解释到这儿了⋯⋯口说无凭，代码为证。写点代码验证一下：定义一个GCTest类代码如下：123456789101112131415161718192021222324252627282930public class GCTest &#123; private String name; public GCTest(String name)&#123; this.name= name; &#125; //覆写finalize()方法 @Override protected void finalize() throws Throwable &#123; // TODO Auto-generated method stub super.finalize(); System.out.println(this.name+"是垃圾，正在被回收"); &#125; public static void main(String[] args) &#123; //创建三个对象 GCTest gt1 = new GCTest("gt1"); GCTest gt2 = new GCTest("gt2"); GCTest gt3 = new GCTest("gt3"); //把对象去掉引用，变成垃圾 gt1=null; gt2=null; gt3=null; //调用gc()方法，主动回收垃圾 System.gc(); &#125;&#125;运行结果留给大家去测试了⋯⋯]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[向上转型，向下转型，还在头疼？]]></title>
    <url>%2F2017%2F05%2F18%2F20170518%2F</url>
    <content type="text"><![CDATA[在学习Java编程中，最头疼事情之一就是数据类型转换。有时候它在不经意之间就完成了（自动类型转换），有时候却又要求程序员必须手动指定（强制类型转换）。基本数据类型，转换规则还可以通过类型本身空间大小和精度分析明白，而且最多就是丢失精度但运行起来至少是不会报错。可是面对引用数据类型，这个“坑”就大了：有自动转的，有强制转的，居然还有强制都转不了的；自动转了的却把对象身上的方法丢了看不见；强制转的编译过了运行却可能报异常。 一口老血，有木有？更要命的是，这个转型还相当的重要，Java中的动态多态还非它不可了。你说要命不要命？没关系，今天就让我们花点时间聊聊它，搞定它！ 对象不是你想转，想转就能转先人说：知己知彼，百战不殆。我们先来认知一下引用数据类型的一些基本概念，以下所有分析都基于两个方面进行：Java语法 和 面向对象场景。在普通情况下，我们会书写这样的代码：1234Dog snoopy = new Dog();snoopy.play();//调用Dog的玩耍行为snoopy.sitDown();//调用Dog的坐下行为snoopy.shakeHands();//调用Dog的握手行为我们看到在这个语法当中，赋值符号左右两边的数据类型是相同。赋值号左边是Dog类的引用snoopy变量，指向了右边new出来的Dog类对象。这个语法在对应的日常场景中是非常形象的。我们用snoopy称呼一个狗对象，并且确定一定以及肯定snoopy就是一个狗东西。然后我们就可以大喊：snoopy来玩游戏啦，snoopy坐下，snoopy握手。你看，多自然。但是，如果我们写出下面的代码：12Dog snoopy = new Cat();snoopy.sitDown();赋值符号左右两边的数据类型是不同。赋值号左边是Dog类的引用snoopy变量，指向了右边new出来的Cat类对象。编译后，你就发现这句代码根本通不过。为什么？因为这个语法是荒谬的。snoopy明明是狗的代名词，结果你却让它指向了一只猫？还想让它执行狗才有的指令？铲屎的，你是不是不想活了？这个时候有同学想到了，那就强转。12Dog snoopy = （Dog）new Cat();snoopy.sitDown();这就更令人发指了吧，你要怎么做才能强行让一只猫咪对象变成一只汪对象？上帝也疯狂了……你觉得Java会让允许你干这种完全匪夷所思不合常理的事情吗？所以，这句代码的下场也只有一个，那就是编译不通过。因此，我们得到了第一个结论：在Java当中不是任意引用数据类型之间都能进行转换！那么，哪些引用类型之间可以呢？ 向上转型—自动转换，没问题我们分别定义两个类：一个叫做Pet（宠物）；一个叫做Dog，并且让Dog继承于Pet。12345public class Pet&#123; public void play()&#123; System.out.println("玩游戏"); &#125;&#125;12345public class Dog extends Pet&#123; public void sitDown()&#123; System.out.println("坐下"); &#125;&#125;那么，我们在需要调用处写下这个代码会发生什么呢？1Pet myBaby = new Dog();你会发现虽然在赋值符号两边的数据类型不一致，但是这句代码无论是编译还是运行都完全没有问题，也就是说Java中父类的引用指向子类对象是自动成功的。 这是为啥呢？其实无论是从语法上还是从场景分析上，我们会发现这是非常自然的，本身就应该自动成功。继承关系本就是一种is a关系，即所谓的“是一个“，所以Dog对象是一个Pet类型的呀（狗就是一种宠物嘛～～），这完全没有问题。在继承关系上，我们设计时通常在继承树上把父类画在上，子类在下，由于这种转型是沿着继承树往上走，所以我们把它称为–向上转型。但是，12myBaby.play();//编译通过myBaby.sitDown();//编译失败这又是为啥呢？因为myBaby是一个Pet类型的引用，所以是站在宠物的角度去看待汪对象。虽然对象还是狗狗，但是只能看到来自于父类宠物定义的play方法了。所以父类引用指向子类对象，只能调用到来自父类的属性／行为那如何调用到sitDown方法呢？答案很简单：换成狗的角度去看待这个汪星人。 向下转型—强制转换，有风险1234Pet myBaby = new Dog();myBaby.play();Dog snoopy = (Dog)myBaby;snoopy.sitDown(); 这段代码无论编译还是运行都不会有任何问题。我们先使用Pet类型的myBaby指向了狗对象，然后再换成Dog类型的snoopy去指向同一个狗对象。前者由于是父类型所以只能看到定义在父类的方法，后者是子类型，当然就可以看到狗对象身上的特有行为了。这种转型是从父类引用转为子类引用，从继承树的角度说就是向下转型。那为什么在把myBaby赋给snoopy的时候要使用强转语法呢？我们假设下面这种情况：如果Pet类还有一个子类叫做Cat类。12345public class Cat extends Pet&#123; public void climbTree()&#123; System.out.println("爬树"); &#125;&#125;然后书写代码：12345public class Master&#123; public void playWithPet(Pet myBaby)&#123; //操作代码 &#125;&#125;那么，你告诉我传进来的myBaby到底是Dog对象呢？还是Cat对象？或者是Pet对象？由于父类引用可以指向子类对象，所以上面几种情况皆有可能了。所以我们如果想转型Dog类，就必须强制告诉Java，myBaby确实是一个Dog类型的对象。因此我们需要在注释部分书写：1Dog snoopy = (Dog)myBaby;不过，就算你这么书写也只能保证编译通过，这个代码运行起来还是有可能失败，这就是所谓的强转风险性吧。如果你赋给myBaby的是🐶对象，当然没有问题；但假如赋的是🐱对象呢？这是不是相当于我们又从狗的角度去看待一个猫对象了？如何让一只狗变成一只猫，这又是一个荒谬的事情了。所以，如果向下转型想要编译和运行都成功，必须使用强制转型语法，还必须要求运行起来父类引用确实指向该子类的对象。所以，为了降低这种风险性，我们可以使用Java中的instance运算符，在强转前进行一次判断。所以最终代码是：123456789public class Master&#123; public void playWithPet(Pet myBaby)&#123; myBaby.play(); if(myBaby instanceof Dog)&#123; Dog snoopy = (Dog)myBaby; snoopy.sitDown(); &#125; &#125;&#125; 结论 在引用数据类型中，只有有继承关系的类型才能进行类型转换； 类型转换只是转换看待对象的引用的类型，对象本身没有也不可能参与转换； 父类引用可以自动指向子类对象，但只能访问和调用到来自于父类的属性和行为； . 子类的引用不能指向父类或其它子类对象，就算强转也会导致运行失败并抛出ClassCastException； . 把父类引用赋给子类引用，语法上必须使用强制类型转换，要想运行也成功还必须保证父类引用指向的对象一定是该子类对象（最好使用instance判断后，再强转）。]]></content>
      <categories>
        <category>JavaOO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[本博客书写教程：关于内容与风格]]></title>
    <url>%2F2017%2F05%2F08%2FcontentCourse%2F</url>
    <content type="text"><![CDATA[这篇文章是专门针对博客书写者进行内容选择与书写的一个简单说明。它主要涵盖了本博的目标人群、内容选取、书写风格这三个方面的要求。大家可以通过这些对自己的文章进行选题和渲染，既做到有的放矢又能够循循善诱寓教于乐，从而让本博发挥最有效的作用。 关于目标人群我们设定读取本博客的受众主要分为两种人群：1、LOVO教育Java方向的在读同学，在课后对学习内容回顾或扩展时可以通过阅读本博有所收获；能够在掌握学校教学内容的同时，又能够从更多角度看待这些知识点，还能够接触到更丰富的扩充内容；2、有志于自学Java的同学能够通过关注本博，从目前网络上浩如烟海的学习资源和市面上汗牛充栋的学习书籍中解脱出来；在这里能够获得清晰的学习结构，详细的学习内容和多维的学习方式，从而达到事半功倍的效果。 关于内容选取通过目标人群的设定，我们确定本博内容主要是依托朗沃的Java教材体系结构，针对Java课程的学习者（当然也包括愿意跟随朗沃体系结构进行自学的爱好者），提供教学内容的重点和难点进行讲解和扩展，并针对在面试中常见的一些题目进行解析回答。从内容分类上主要包括：计算机常识；Java基础编程；Java面向对象；数据库；客户端；JavaWeb；JavaEE框架；面向对象分析与设计；面试模拟问答等方面。 关于书写风格本博其实是朗沃教育在课堂之外的衍生，也是教学过程的一种辅助手段，所以在文章风格上还是以严谨但不失风趣为主，让阅读者能够在较为轻松的环境中有所收获。此外在手段上，除了文字和排版上要做到简练有趣，突出重点，如果还能配上合适的代码或图片更佳。总之，本博希望成为一个能够吸引各位读者的学习平台，让大家能够更有收获。]]></content>
      <categories>
        <category>本博教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[本博客书写教程：关于书写格式]]></title>
    <url>%2F2017%2F05%2F07%2FwriteCourse%2F</url>
    <content type="text"><![CDATA[本博客是发布在github上的，而github上提供挂载的是静态网站和静态资源，是一种低成本的公共展示手段。我们利用hexo这个工具把本地的MarkDown文件自动生成为静态页面，然后再上传到github上。所以，各位老师要为本博客提供的原文件必须是一篇能被hexo正确解析的MarkDown文件。接下来，我们就来介绍一下这种格式。 文件开头在文件的开头部分，请按照下图的方式进行书写：1、首先用三根短横线开头，再用三根短横线结束；2、中间内容分别是标题（title）、日期（date）和分类（categories）；3、注意冒号后面一定要有一个空格。 文件内容在完成文件开头后，你可以在下一行开始书写内容了。在书写内容时，请先在第一段用简短的文字书写一个内容概要，然后换行使用more标记进行分割。这样，这篇文章在首页就只会显示第一段内容，只有点击《阅读全文》才能看到后面的内容了。书写方式和效果如下：文章内容在书写过程中，只需要在每段的结束时换行，不需要（也不能）在每段开始的时候使用TAB或空格进行缩进。其余效果语法请参见MarkDown语法即可。 如何插入图片在文中插入图片是我们书写时的重要的说明手段，在HEXO中有两种语法可以插入图片，这里我们推荐使用:图片路径可以由上传者调整，但是需要各位作者老师把图片一同交与上传者。请注意：图片最好使用jpg或png格式；另外为节约空间，图片大小最好保持在几百k就够了；图片的名称请按照在文章中出现的顺序数字进行命名。 如何插入代码技术文章当然少不了代码的出现，HEXO中采用的支持语法是：用codelock和endcodelock把你的代码括起来，其中lang属性后面跟上代码的所属语言即可。HEXO可以自动找出该语言的关键字、变量、注释等进行变颜色操作。效果如下：1234567try &#123;... //需要异常处理的代码&#125; catch（） &#123;...//捕获到异常后执行的代码&#125; finally &#123;…//有没有捕获到异常都要执行的代码&#125;]]></content>
      <categories>
        <category>本博教程</category>
      </categories>
  </entry>
</search>